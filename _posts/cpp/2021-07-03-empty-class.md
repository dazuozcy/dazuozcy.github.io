---
layout: post
title: "class的内存模型"
author: dazuo
date: 2020-07-03 20:19:00 +0800
categories: [C++]
tags: [空类，深拷贝，浅拷贝]
math: true
mermaid: true
---

# 关于默认构造函数

> 惟有当默认构造函数**被需要**(被调用)，它们才会被编译器创建出来。

## 什么是默认构造函数

默认构造函数是可以不用实参进行调用的构造函数，它包括了以下两种情况：

- 没有带明显形参的构造函数。
- 提供了默认实参的构造函数。

类设计者可以自己写一个默认构造函数。编译器帮我们写的默认构造函数，称为“**合成的默认构造函数**”。强调“没有带明显形参”的原因是编译器总是会为构造函数形参表插入一个隐含的this指针，所以”本质上”是没有不带形参的构造函数的，只有不带明显形参的构造函数，它就是默认构造函数。

## 默认构造函数什么时候被调用

如果定义一个对象时没有提供初始化式，就使用默认构造函数。例如：

```cpp
class A {
    
};

int main() {
    A a; // 调用类A的默认构造函数
    return 0;
}
```

## 理解"被需要"

引言中的”被需要“怎么理解。被谁需要? 做什么事情？像下面这段代码，默认构造函数”被需要“了吗？

```cpp
class A {
public:
    bool is_true_;
    int num_;
};

int main() {
    A a;
    cout << a.is_true_ << endl;
    cout << a.num_ << endl;
    return 0;
}
```

你可能认为这里定义类对象a的时候没有提供参数且A没有定义默认构造函数，编译器应该会合成一个默认构造函数并调用它来初始化A的数据成员，实则不是。上述代码在`gcc 7.3`下输出的结果是

```shell
24
32764
```

看起来是个垃圾值。

当类只含有内置类型或复合类型的成员时，编译器是不会为类合成默认构造函数的，这种类并不符合”被需要“的条件，甚至当类满足“被需要”条件，编译器合成了默认构造函数时，类中内置类型与复合类型数据成员依然不会在默认构造函数中进行初始化。C++ Primer中也有提到：“如果类包含内置或复合类型的成员，则该类不应该依赖于合成的默认构造函数“。

上面代码中，默认构造函数”被需要“是对程序来说的，程序需要is_true_, num\_被初始化以便可以输出。然而这种需要并不会促使编译器合成默认构造函数。**惟有被编译器所需要**时，编译器才会合成默认构造函数。那怎样的类才是编译器需要合成默认构造函数的呢？

## 编译器总是需要默认构造函数的四种类

### 1. 含有类对象成员，该类对象成员有默认构造函数



### 2. 带有默认构造函数的类的派生类



### 3. 带有虚函数的类



### 4. 带有虚基类的类









# C++类对象的内存分布

#### 空类

```cpp
class Empty {
};

sizeof(Empty)  // 1 byte
```

如果实例化一个空类，这个对象会在内存中占用1个字节。目的是标识一下这是一个类的实例。

#### 只含成员变量，不含成员函数

C++类成员变量的内存分布是**从上到下**，按照**内存对齐的原则**进行分布的。

内存对齐原则：

- 分配内存的顺序是按照声明的顺序；
- 每个变量相对于起始位置的偏移量必须是该变量类型大小的整数倍，不是整数倍则padding成整数倍；
- 最后整个类的大小必须是里面变量类型最大值的整数倍。

类的static成员变量是该类的所有对象共享的，不占对象的内存空间。

#### 带普通成员函数

用类定义对象时，系统会为每个对象分配存储空间。成员函数是不占实例内存的，因为一个类的成员函数是共享的，一个类的函数只有一份。这一份具体存放在哪取决于编译器。

#### 带虚函数的类

虚函数表也是每个类一份。但是类的每个实例会有一个虚函数表指针。

```cpp
class B {
public:
    long b;
    virtual void foo() {}
    virtual void bar() {}
};

class D : public B {
public:
    long d;
    virtual void bar() {}
    virtual void quz() {}
};
```

![image-20220115181213343](../../img/cpp/class_memory.png){: width="1086" height="542"}

#### 虚函数表的生成

父类的虚函数表会根据自身的虚函数自动生成。子类的虚函数表会先拷贝父类的虚函数表，然后替换父类中的同名虚函数，最后补上子类自己的虚函数。

![image-20220115182304782](../../img/cpp/generate_vptr.png){: width="1086" height="542"}





## 内存字节对齐，什么因素影响字节对齐，可以1字节对齐吗

理论上计算机对于任何变量的访问都可以从任意位置开始， 然而实际上系统会对这些变量的存放地址有限制， 通常将变量首地
址设为某个数 N 的倍数， 这就是内存对齐。

为什么要内存对齐

- 平台原因：内存以字节为单位，不同硬件平台不一定支持任何内存地址的存取，一般以2字节、4字节等为单位存取内存，为了保证处理器正确存取数据，需要进行内存对齐。
- 性能原因：提高CPU内存访问速度，一般处理器的内存存取粒度都是N的整数倍，假如访问N大小的数据，没有进行内存对齐，有可能就需要两次访问才可以读取出数据，而进行内存对齐可以一次性把数据全部读取出来，提高效率。



需要一个机制来建立一个工作环境（构造函数）和一个逆操作来释放运行期获得的资源（析构函数）。以下摘自1979 年的实验记录本：

> - “new 函数”为成员函数创建运行的环境
> - “delete 函数”则执行相反的操作

空class有六个默认函数：

- 默认构造函数/
- 复制构造函数
- 析构函数
- 赋值运算符
- 取址运算符
- 取址运算符const

```cpp
class Empty {
public:
  Empty();                           // 默认构造函数
  Empty(const Empty& );             // 拷贝构造函数
  ~Empty();                          // 析构函数
  Empty& operator=(const Empty&);  // 赋值运算符
  Empty* operator&();                // 取址运算符
  const Empty* operator&() const;    // 取址运算符 const};
}
```

### 深拷贝与浅拷贝区别
https://zhuanlan.zhihu.com/p/342851361

https://zhuanlan.zhihu.com/p/188311618

### 赋值函数，拷贝函数
### 手写深拷贝，动态分配内存
### 写一个拷贝构造函数？为什么引用传递而不是值传递
