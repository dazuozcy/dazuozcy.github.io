---
layout: post
title: "class的内存模型"
author: dazuo
date: 2020-07-03 20:19:00 +0800
categories: [C++]
tags: [空类，深拷贝，浅拷贝]
math: true
mermaid: true
---

# C++类对象的内存分布

#### 空类

```cpp
class Empty {
};

sizeof(Empty)  // 1 byte
```

如果实例化一个空类，这个对象会在内存中占用1个字节。目的是标识一下这是一个类的实例。

#### 只含成员变量，不含成员函数

C++类成员变量的内存分布是**从上到下**，按照**内存对齐的原则**进行分布的。

内存对齐原则：

- 分配内存的顺序是按照声明的顺序；
- 每个变量相对于起始位置的偏移量必须是该变量类型大小的整数倍，不是整数倍则padding成整数倍；
- 最后整个类的大小必须是里面变量类型最大值的整数倍。

类的static成员变量是该类的所有对象共享的，不占对象的内存空间。

#### 带普通成员函数

用类定义对象时，系统会为每个对象分配存储空间。成员函数是不占实例内存的，因为一个类的成员函数是共享的，一个类的函数只有一份。这一份具体存放在哪取决于编译器。

#### 带虚函数的类

虚函数表也是每个类一份。但是类的每个实例会有一个虚函数表指针。

```cpp
class B {
public:
    long b;
    virtual void foo() {}
    virtual void bar() {}
};

class D : public B {
public:
    long d;
    virtual void bar() {}
    virtual void quz() {}
};
```

![image-20220115181213343](../../img/cpp/class_memory.png){: width="1086" height="542"}

#### 虚函数表的生成

父类的虚函数表会根据自身的虚函数自动生成。子类的虚函数表会先拷贝父类的虚函数表，然后替换父类中的同名虚函数，最后补上子类自己的虚函数。

![image-20220115182304782](../../img/cpp/generate_vptr.png){: width="1086" height="542"}





## 内存字节对齐，什么因素影响字节对齐，可以1字节对齐吗

理论上计算机对于任何变量的访问都可以从任意位置开始， 然而实际上系统会对这些变量的存放地址有限制， 通常将变量首地
址设为某个数 N 的倍数， 这就是内存对齐。

为什么要内存对齐

- 平台原因：内存以字节为单位，不同硬件平台不一定支持任何内存地址的存取，一般以2字节、4字节等为单位存取内存，为了保证处理器正确存取数据，需要进行内存对齐。
- 性能原因：提高CPU内存访问速度，一般处理器的内存存取粒度都是N的整数倍，假如访问N大小的数据，没有进行内存对齐，有可能就需要两次访问才可以读取出数据，而进行内存对齐可以一次性把数据全部读取出来，提高效率。



需要一个机制来建立一个工作环境（构造函数）和一个逆操作来释放运行期获得的资源（析构函数）。以下摘自1979 年的实验记录本：

> - “new 函数”为成员函数创建运行的环境
> - “delete 函数”则执行相反的操作

空class有六个默认函数：

- 默认构造函数/
- 复制构造函数
- 析构函数
- 赋值运算符
- 取址运算符
- 取址运算符const

```cpp
class Empty {
public:
  Empty();                           // 默认构造函数
  Empty(const Empty& );             // 拷贝构造函数
  ~Empty();                          // 析构函数
  Empty& operator=(const Empty&);  // 赋值运算符
  Empty* operator&();                // 取址运算符
  const Empty* operator&() const;    // 取址运算符 const};
}
```

### 深拷贝与浅拷贝区别
https://zhuanlan.zhihu.com/p/342851361

https://zhuanlan.zhihu.com/p/188311618

### 赋值函数，拷贝函数
### 手写深拷贝，动态分配内存
### 写一个拷贝构造函数？为什么引用传递而不是值传递
