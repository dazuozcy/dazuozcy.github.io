---
layout: post
title: "C++11开始的新特性"
author: dazuo
date: 2020-07-03 20:19:00 +0800
categories: [C++]
tags: [C++11]
math: true
mermaid: true
---

[C++11新特性](https://zhuanlan.zhihu.com/p/139515439)

语言

- Initializer list

- variadic templates
- move
- auto
- range-based for loop
- lambda

标准库
- type traits
- unordered container
- forward list
- array
- tuple
- con-currency
- regex



# initializer list(初始化列表， since c++11)

和`vector`一样，`initializer_list`也是一种模板类。

```cpp
initializer_list<T>
void print(initializer_list<int> vals) {
    for(auto p = vals.begin(); p != vals.end(); ++p) {
        cout << *p;
    }
}

print({1,3,5,7,9});  // 必须以initializer_list<int>或者{...}的形式调用
```



# variadic templates(可变参数模板, since c++11)

> 谈的是templates

- function template
- class template

> 变化的是template parameters

- 参数个数，利用参数个数逐一递减的特性，实现递归调用，基于function template
- 参数类型，利用参数个数逐一递减导致参数类型数量也逐一递减的特性实现递归继承或者递归复合，基于class template

可以方便地完成递归函数调用。

可以方便地完成递归类继承。

## 可变模板参数函数

```cpp
template <class... T>
void f(T... args) {    
    cout << sizeof...(args) << endl;  // 在模板里面使用`sizeof...(args)`可以打印模板参数的数量。
}

int main() {
	f();        //0
	f(1, 2);    //2
	f(1, 2.5, "");    //3    
}
```

由于可变模版参数的类型和个数是不固定的，所以我们可以传任意类型和个数的参数给函数`f`。这个例子只是简单的将可变模版参数的个数打印出来，如果需要将参数包中的每个参数打印出来的话就需要通过一些方法了。展开可变模版参数函数的方法一般有两种：

- 通过递归函数来展开参数包

  通过递归函数展开参数包，需要提供一个参数包展开函数和一个递归终止函数，递归终止函数正是用来终止递归的。下面是例子

  ```cpp
  // 递归终止函数
  void print() {
  }
  
  // 参数包展开函数，每递归调用一次，参数包中的参数就少一个
  template <typename T, typename... Types>
  void print(const T& firstArg, const Types&... args) {  
  	cout << firstArg << endl;    
  	print(args...);
  }
  
  int main() {
      print(7.5, "hello", 666);
  }
  ```

- 通过逗号表达式来展开参数包

  递归函数展开参数包是一种标准做法，也比较好理解，但也有一个缺点,就是必须要一个重载的递归终止函数，即必须要有一个同名的终止函数来终止递归，这样可能会感觉稍有不便。有没有一种更简单的方式呢？其实还有一种方法可以不通过递归方式来展开参数包，这种方式需要借助逗号表达式和初始化列表。

  ```cpp
  template <class T>
  void printarg(T t) {
     cout << t << endl;
  }
  
  template <class ...Args>
  void expand(Args... args) {
     int arr[] = {(printarg(args), 0)...};
  }
  
  expand(1,2,3,4);
  ```

  `expand`函数中的逗号表达式`(printarg(args), 0)`先执行`printarg(args)`，再得到逗号表达式的结果`0`。

  同时还用到了`C++11`的另外一个特性——**初始化列表**，通过初始化列表来初始化一个变长数组, `{(printarg(args), 0)...}`将会展开成`((printarg(arg1),0), (printarg(arg2),0), (printarg(arg3),0), ...)`，最终会创建一个元素值都为`0`的数组int arr[sizeof...(Args)]。

  由于是逗号表达式，在创建数组的过程中会先执行逗号表达式前面的部分`printarg(args)`打印出参数，也就是说在构造`arr`数组的过程中就将参数包展开了，这个数组的目的纯粹是为了在数组构造的过程展开参数包。

  将上面的实现改进一下，少写最后的递归终止函数。如下所示：

  ```cpp
  template<class F, class ...Args>
  void expand(const F& f, Args...args) {
    std::initializer_list<int>{(f(args), 0)...};
  }
  
  expand([](int i){std::cout << i << std::endl;}, 1,2,3);
  ```



## 可变模板参数类

https://www.cnblogs.com/qicosmos/p/4325949.html



# std::is_same与std::decay
std::is_same<Type_a, Type_b>::value, 可以用于模板参数检查。严格判断类型是否一致(int, int&, const int, const int& 都不是同一种类型)。int和signed int是同一种。char和signed char不是同一种。char和unsigned char也不是同一种。
   如果不需要如此严格的校验,可以利用std::decay.
std::is_same<typename std::decay<Type_a>::type, Type_b>::value,
这个检查对于int, int&, int&&, const int&，会判断是同一种类型；int[2]与int*是同种类型， int(int)与int(*)(int)是同种类型。

# auto与decltype

## auto

1. C++是一种强类型语言，声明变量时必须明确指出其类型。
2. 实践中，有时人工很难推断出某个表达式值的类型，并且类型的名字可能会很长，尤其在泛型编程里。
  为了解决这个问题，C++11重新定义了auto的语义(以前是用于声明自动变量)，其核心在于类型推导(type deduction)，让编译器在编译期（非运行期）推导出表达式的类型。
  auto主要有2个用途：
3. 在变量声明时，根据初始化表达式自动推导该变量的类型。
4. 在声明函数时，作为函数返回值的占位符。

### 注意事项

1. 使用auto关键字的变量必须有初始值。

2. 可以使用`valatile`，*，&，&&来修饰auto关键字。

   ```cpp
   auto a = 10;
   auto *pa = new auto(a);
   auto **rpa = new auto(&a);
   cout << typeid(a).name() << endl;   // 输出： int
   cout << typeid(pa).name() << endl;  // 输出： int *
   cout << typeid(rpa).name() << endl; // 输出： int **
   ```

3. 函数参数和模板参数不能被声明为auto。

4. 使用auto关键字声明变量的类型，不能自动推导出顶层的CV-qualifiers和引用类型，除非显示声明。CC 是指const 和volatile。

   - 使用auto关键字进行类型推导时，如果初始化表达式是引用类型，编译器会去除引用，除非显示声明。例如：

     ```cpp
     int i = 10;
     int &r = i;
     auto a = r;
     a = 13; // 重新赋值
     cout << "i = " << i << " a = " << a << endl;    // 输出i=10，a=13
     
     // 显式声明
     auto &b = r;
     b = 15; // 重新赋值
     cout << "i = " << i << " b = " << b << endl;    // 输出i=15，a=15
     ```

   - 使用auto使用auto关键字进行类型推导时，编译器会自动忽略顶层const，除非显示声明。例如：

     ```cpp
     const int c1 = 10;
     auto c2 = c1;
     c1 = 11; // 报错，c1为const int类型，无法修改const变量
     c2 = 14; // 正确，c2为int类型
     
     // 显示声明
     const auto c3 = c1;
     c3 = 15; // 报错，c3为const int类型，无法修改const变量
     ```

5. 对于数组类型，auto关键字会推导为指针类型，除非被声明为引用。例如：

   ```cpp
   int a[10];
   auto b = a;
   cout << typeid(b).name() << endl;   // 输出：int *
   
   auto &c = a;
   cout << typeid(c).name() << endl;   // 输出：int [10]
   ```

6. 在类中auto不能用作非静态成员常量

   ```cpp
   class A {
       // error: non-static data member declared with placeholder 'auto'
       auto a = 1;
       
       // error: ISO C++ forbids in-class initialization of non-const static member 'A::b'
       static auto b = 1; 
       
       static const auto c = 1; // ok
   };
   ```

[参考]:(https://veitchkyrie.github.io/2020/02/19/C++-11-auto%E5%85%B3%E9%94%AE%E5%AD%97/)

## decltype

decltype用于推导表达式类型，其只用于编译器分析表达式的类型， 表达式实际不会进行运算。

decltype不会像auto一样忽略引用和CV属性，decltype会保留表达式的引用和cv属性。

对于`decltype(exp)`有:

- 若`exp`是表达式，`decltype(exp)`和`exp`类型相同
- 若`exp`是函数调用，`decltype(exp)`和函数返回值类型相同
- 其它情况，若`exp`是左值，`decltype(exp)`是`exp`类型的左值引用

```cpp
int a = 0, b = 0;
decltype(a + b) c = 0; // c 是 int， 因为(a+b)返回一个右值
decltype(a += b) d = c;// d 是 int&， 因为(a+=b)返回一个左值
d = 20;
cout << "c " << c << endl; // 输出 c 20
```



## auto与decltype配合使用

auto与decltype配合使用，作为返回值类型后置时的占位符。此时，auto不表示自动类型检测，仅表示后置返回值的语法的一部分。

```cpp
template<class T, class U>
auto add(T t, U u) -> decltype(t + u) 
{
    return t + u;
}
```

从C++14开始，例子中的 ->decltype(t+u)就不再需要，可以去掉了。

# for_each

一种STL泛型算法
```cpp
template<class InputIterator, class Function>
  Function for_each(InputIterator first, InputIterator last, Function fn)
{
  while (first!=last) {
    fn(*first);
    ++first;
  }
  return fn;      // or, since C++11: return move(fn);
}
// fn是unary function.
```

# nullptr
用来代替`0`或者`NULL`.

```cpp
void f(int);
void f(void*);

f(0);       // 调用f(int);
f(NULL);    // 会有歧义，调用f(int) if NULL is 0。
f(nullptr); // 调用f(void*)
```

# std::forward, std::move, 右值，右值引用，移动构造函数


# emplace_back(), push_back()

# lamda表达式
# std::bind， std::function

# 统一的类成员初始化方法与std::initializer_list
# 注解标签（attributes）
# final, override,=default,=delete语法

# range-based循环语法
```cpp
template<typename T>
void PrintElemets(const T& coll) {
  for (const auto& ele : coll) {
    cout << ele;
  }
}

//上面的for循环等价于下面这样
for (auto _pos = coll.begin(); _pos != coll.end(); ++_pos) {
  const auto ele& = *_pos;
  cout << ele;
}
```
# 结构化绑定


# std::thread
# 线程局部存储thread_local
# 线程同步原语std::mutex, std::condition_variable

并行算法(from C++17)
https://zhuanlan.zhihu.com/p/372004337