---
layout: post
title: "C++11开始的新特性"
author: dazuo
date: 2020-07-03 20:19:00 +0800
categories: [C++]
tags: [C++11]
math: true
mermaid: true
---

[C++11新特性](https://zhuanlan.zhihu.com/p/139515439)

语言
- variadic templates
- move
- auto
- range-based for loop
- Initializer list
- lambda

标准库
- type traits
- unordered container
- forward list
- array
- tuple
- con-currency
- regex

# 数量不定的模板参数(variadic templates)
```cpp
void print() {

}

template <typename T, typename... Types>
void print(const T& firstArg, const Types&... args)
{  
	cout << firstArg << endl;    
	print(args...);
}
```
在模板里面使用`sizeof...(args)`可以打印模板参数的数量。

```cpp
void print() {

}

template <typename... Types>
void print(const Types&... args)
{  
	print(args...);
}
```

可以方便地完成递归函数调用。

可以方便地完成递归类继承。

# std::is_same与std::decay
std::is_same<Type_a, Type_b>::value, 可以用于模板参数检查。严格判断类型是否一致(int, int&, const int, const int& 都不是同一种类型)。int和signed int是同一种。char和signed char不是同一种。char和unsigned char也不是同一种。
   如果不需要如此严格的校验,可以利用std::decay.
std::is_same<typename std::decay<Type_a>::type, Type_b>::value,
这个检查对于int, int&, int&&, const int&，会判断是同一种类型；int[2]与int*是同种类型， int(int)与int(*)(int)是同种类型。

# auto与decltype
1. C++是一种强类型语言，声明变量时必须明确指出其类型。
2. 实践中，有时人工很难推断出某个表达式值的类型，并且类型的名字可能会很长，尤其在泛型编程里。
为了解决这个问题，C++11重新定义了auto的语义(以前是用于声明自动变量)，其核心在于类型推导(type deduction)，让编译器在编译期（非运行期）推导出表达式的类型。
auto主要有2个用途：
1. 在变量声明时，根据初始化表达式自动推导该变量的类型。
2. 在声明函数时，作为函数返回值的占位符。
在第2个用途中，auto主要与decltype(内置函数，返回参数的声明类型)配合使用，作为返回值类型后置时的占位符。此时，auto不表示自动类型检测，仅表示后置返回值的语法的一部分。
从C++14开始，例子中的 ->decltype(t+u)就不再需要，可以去掉了。
[注意事项]:(https://veitchkyrie.github.io/2020/02/19/C++-11-auto%E5%85%B3%E9%94%AE%E5%AD%97/)

# for_each
一种STL泛型算法
```cpp
template<class InputIterator, class Function>
  Function for_each(InputIterator first, InputIterator last, Function fn)
{
  while (first!=last) {
    fn(*first);
    ++first;
  }
  return fn;      // or, since C++11: return move(fn);
}
// fn是unary function.
```

# nullptr
用来代替`0`或者`NULL`.

```cpp
void f(int);
void f(void*);

f(0);       // 调用f(int);
f(NULL);    // 会有歧义，调用f(int) if NULL is 0。
f(nullptr); // 调用f(void*)
```

# std::forward, std::move, 右值，右值引用，移动构造函数


# emplace_back(), push_back()

# lamda表达式
# std::bind， std::function

# 统一的类成员初始化方法与std::initializer_list
# 注解标签（attributes）
# final, override,=default,=delete语法

# range-based循环语法
```cpp
template<typename T>
void PrintElemets(const T& coll) {
  for (const auto& ele : coll) {
    cout << ele;
  }
}

//上面的for循环等价于下面这样
for (auto _pos = coll.begin(); _pos != coll.end(); ++_pos) {
  const auto ele& = *_pos;
  cout << ele;
}
```
# 结构化绑定


# std::thread
# 线程局部存储thread_local
# 线程同步原语std::mutex, std::condition_variable

并行算法(from C++17)
https://zhuanlan.zhihu.com/p/372004337