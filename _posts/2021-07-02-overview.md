---
layout: post
title: "Overview"
author: dazuo
date: 2021-06-10 10:33:00 +0800
categories: [overview]
tags: [overview]
math: true
mermaid: true
sidebar: auto
---

- 基本原理：设计这个特性是为了帮助解决哪类问题？其设计原理是什么？它有什么根本的局限？
- 规范：它该如何定义？
- 例子：当单独使用这个特性或与其他特性组合使用时，如何用好它？其中的关键技术和习惯用法是怎样的？在程序的可维护性和性能方面是否有一些隐含的问题？


# C++

## [C++ vs C](/posts/diff-between-c-cpp)

## [面向对象的特性](/posts/object-oriented-character)

## [STL](/posts/stl)

## [智能指针](/posts/smart-pointers)

## [C++编译过程和内存分区](/posts/about-compiling)

## [构造函数-析构函数](/posts/constructor-destructor)

## [空class](/posts/empty-class)

### 变量声明，定义区别
- 定义
  用于创建新的对象，确定对象的类型并分配内存，只能出现在一个地方。

- 声明
  用于指代其他地方定义的对象，描述对象的类型，可以出现多次。

定义是一种特殊的声明。


### 指针vs引用
指针和引用的相同点：
1、都能提供对其他对象的间接访问

指针和引用的不同点：
1、引用并非对象，它只是为一个已经存在的对象所起的一个别名；
指针本事就是一个对象，允许对指针赋值和拷贝
2、一旦定义了引用，就无法令其再绑定到另外的对象上去；
指针可以先后指向几个不同的对象
3、引用定义的时候，必须赋初值；
指针无须再定义的时候赋初值，在块作用域定义的指针如果没有被初始化，也将拥有一个不确定的值

https://zhuanlan.zhihu.com/p/89175296

https://zhuanlan.zhihu.com/p/68208313



## 内存溢出与内存泄漏
### 内存泄漏memory leak:
是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。
### 内存溢出out of memory:
OOM,即所谓的内存溢出。指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错。

### 二者的关系
- 内存泄漏的堆积最终会导致内存溢出。
- 内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误。
- 内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。就相当于你租了个带钥匙的柜子，你存完东西之后把柜子锁上之后，把钥匙丢了或者没有将钥匙还回去，那么结果就是这个柜子将无法供给任何人使用，也无法被垃圾回收器回收，因为找不到他的任何信息。
- 内存溢出：一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出。比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出。


## 野指针产生与避免
野指针通常是指指针变量中保存的值不是一个合法的内存地址或者指向不可用内存。

### 产生
- 使用未初始化的指针
- 指针所指的对象已经消亡
- 指针释放后之后未置空

### 避免
- C++引入了引用机制，如果使用引用可以达到编程目的，就可以不必使用指针。因为引用在定义的时候，必须初始化，所以可以避免野指针的出现。
- 如果一定要使用指针，那么需要在定义指针变量的同时对它进行初始化操作。定义时将其置位NULL或者指向一个有名变量。
- 对指针进行free或者delete操作后，将其设置为NULL。


## extern关键字
两个作用：

一、与"C"一起连用时，如: `extern "C" void fun(int a, int b);`，告诉编译器在遇到`fun`这个函数名时按着C的规则去找相应的函数名而不是C++的

二、当extern不与"C"在一起修饰变量或函数时，如在头文件中: extern int g_Int; 它的作用就是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块活其他模块中使用。


## static关键字
static用法总览：

![about-static](https://github.com/dazuozcy/dazuozcy.github.io/blob/master/img/about-static.png?raw=true){: width="1086" height="542"}

[参考](https://zhuanlan.zhihu.com/p/37439983)


## const关键字
修饰变量，指针，类对象、类中成员函数

## volatile关键字：避免编译器指令优化

## 如何用C来实现抛出捕获异常
异常处理机制使得正常代码和错误处理隔离开来，代码整体更清晰简洁，可维护性好。
VC++ builds its exception handling support on top of structured exception handling (SEH) provided by Windows operating system.
https://www.zhihu.com/question/20597909


## 判断程序是死循环还是死锁
① PS 查询 相关进程的PID 
② top -P   PID   查询该进程占用资源情况    主要查看的是  cpu  和 内存  的占用率
（如果CPU占用率高就是死循环， 如果CPU占用率正常，而且内存占用正常，那就是死锁）
如果有问题，就去详分析该进程底下 各个是哪个线程出现的问题
③ top -Hp  PID     该进程底下各线程的CPU、内存占用情况  


## [四种类型转换](/posts/four-kinds-of-cast)

## 虚函数作用，什么是纯虚函数，虚函数可以是静态的吗

## 静态函数，虚函数区别

## 虚函数的底层机制，虚函数指针何时生成，在多继承下怎样。虚函数表，存在哪

## 数组对象怎么析构，怎么释放

## 虚表布局，菱形继承

## 介绍多态，是怎么实现的

## 虚函数实现动态多态的原理

## 运行时多态，编译时多态（动态多态，静态多态（重载，重写，模板））

## 类的内存布局

## 继承的底层原理

### 讲解一下动态绑定和静态绑定

### 手写string类


### new/delete与malloc/free区别，new的实质，判断new是否成功的方法
operator new里会调用malloc

### malloc() mmap()底层实现


## 结构体中使用指针和对象有哪些好处



### B继承A,且有虚析构函数， A* a = new B; 中若调用虚析构函数，会调用父类A的还是子类B的析构函数


### RAII与pimpl惯用法

## [C++里好的编码技巧](/posts/good-practice-in-cpp)


## [C++11开始的新特性](/posts/new-from-cpp11)

### 原子操作类
### 智能指针类
### 多线程
### 设计线程池

## 设计模式
### 如何8保证单例模式只有唯一实例，单例模式的多线程安全性。
### 工厂模式优点

# Python

## python的set()底层是什么数据结构
hash表

## python装饰器作用

## 提高python效率的方法
pythonic


# 数据结构与算法
## 数组

## 链表

## 栈

## 队列

## 堆

## 二叉树：二叉搜索树，平衡树，红黑树，

## 红黑书与普通二叉树区别，红黑树自平衡是自动平衡吗，怎么实现自平衡

## B树、B+树

## 哈希表及哈希冲突

## 解决hash冲突的方法,说一下一致性hash

## 快排过程/时间复杂度

## 二分查找

## 回溯法

## 动态规划

## 如何判断两个链表相交？如果两个链表有环怎么办

## 如何给链表排序？时间复杂度O(nlogn),空间复杂度O(1)

## TopK如何用堆排序实现


# 操作系统
## 堆栈的区别

## 有了进程，为什么还要线程

## 多进程与多线程比较

## 孤儿进程与僵尸进程

## 单核机器上写多线程，是否要考虑加锁

## 线程间共享内存，什么时候用到条件变量，什么时候用到锁

## 线程间同步方式：互斥锁，自旋锁，读写锁，条件变量

## 互斥锁与自旋锁的底层区别

## 死锁及避免

## 线程上下文切换的流程

## 进程上下文切换的流程

## 进程的调度算法

## 缓冲区溢出漏洞

## free()入参是void*,如何知道大小

## 内存碎片是什么？有几种形式，产生的原因是什么

## 字节序，如何转化

## (struct)内存字节对齐，为什么要字节对齐，什么因素影响字节对齐，可以1字节对齐吗

## 协程

## 阻塞IO，非阻塞IO。

## 同步，异步

## [静态链接与动态链接的过程](https://zhuanlan.zhihu.com/p/149235029)

## 虚拟内存的概念

## MMU地址翻译的具体流程

## 缺页处理过程

## 缺页置换算法：最久未使用，先进先出，最佳置换


# Linux
## 用户态，内核态，来回切换为什么效率低

## Linux进程间通信方式
PIPE,FIFO,消息队列，信号量，共享内存，socket

## 管道与消息队列对比

## fork进程的底层：读时共享，写时复制

## fork, wait, exec

# [gdb](/posts/gdb)


# 业务

## 如何设计一个车辆管理系统

## 代码优化怎么做的，重构从哪些方面考虑

## 对AI框架的思考
