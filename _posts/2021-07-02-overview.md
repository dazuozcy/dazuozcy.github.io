---
layout: post
title: "Overview"
author: dazuo
date: 2021-06-10 10:33:00 +0800
categories: [overview]
tags: [overview]
math: true
mermaid: true
sidebar: auto
---

- 基本原理：设计这个特性是为了帮助解决哪类问题？其设计原理是什么？它有什么根本的局限？
- 规范：它该如何定义？
- 例子：当单独使用这个特性或与其他特性组合使用时，如何用好它？其中的关键技术和习惯用法是怎样的？在程序的可维护性和性能方面是否有一些隐含的问题？



基础知识

​	数学：离散数学，线性代数，微积分，概率论

​	五大件：数据结构与算法，计算机组成原理，操作系统，编译原理，计算机网络

编程语言

​	C/C++

​	Python

领域知识

​	比如游戏开发的要熟悉游戏引擎，图形学

碎片知识

​	调试

​	版本管理



语言

​	C/C++

​	Python

数据结构与算法

操作系统

业务

​	基带芯片底层软件

​	深度学习框架

​		算子，pass

​		性能优化

​		量化



# C++

## [C++ vs C](/posts/diff-between-c-cpp)

## [面向对象的特性](/posts/object-oriented-character)

## [STL](/posts/stl)

## [智能指针](/posts/smart-pointers)

## [C++编译过程和内存分区](/posts/about-compiling)

## [构造函数-析构函数](/posts/constructor-destructor)

## [空class](/posts/empty-class)

### 变量声明，定义区别
- 定义
  用于创建新的对象，确定对象的类型并分配内存，只能出现在一个地方。

- 声明
  用于指代其他地方定义的对象，描述对象的类型，可以出现多次。

定义是一种特殊的声明。


### 指针vs引用
指针和引用的相同点：
1、都能提供对其他对象的间接访问

指针和引用的不同点：
1、引用并非对象，它只是为一个已经存在的对象所起的一个别名；
指针本事就是一个对象，允许对指针赋值和拷贝
2、一旦定义了引用，就无法令其再绑定到另外的对象上去；
指针可以先后指向几个不同的对象
3、引用定义的时候，必须赋初值；
指针无须再定义的时候赋初值，在块作用域定义的指针如果没有被初始化，也将拥有一个不确定的值

https://zhuanlan.zhihu.com/p/89175296

https://zhuanlan.zhihu.com/p/68208313



## 内存溢出与内存泄漏
### 内存泄漏memory leak:
是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。
### 内存溢出out of memory:
OOM,即所谓的内存溢出。指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错。

### 二者的关系
- 内存泄漏的堆积最终会导致内存溢出。
- 内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误。
- 内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。就相当于你租了个带钥匙的柜子，你存完东西之后把柜子锁上之后，把钥匙丢了或者没有将钥匙还回去，那么结果就是这个柜子将无法供给任何人使用，也无法被垃圾回收器回收，因为找不到他的任何信息。
- 内存溢出：一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出。比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出。


## 野指针产生与避免
野指针通常是指指针变量中保存的值不是一个合法的内存地址或者指向不可用内存。

### 产生
- 使用未初始化的指针
- 指针所指的对象已经消亡
- 指针释放后之后未置空

### 避免
- C++引入了引用机制，如果使用引用可以达到编程目的，就可以不必使用指针。因为引用在定义的时候，必须初始化，所以可以避免野指针的出现。
- 如果一定要使用指针，那么需要在定义指针变量的同时对它进行初始化操作。定义时将其置位NULL或者指向一个有名变量。
- 对指针进行free或者delete操作后，将其设置为NULL。

## 如何用C来实现抛出捕获异常
异常处理机制使得正常代码和错误处理隔离开来，代码整体更清晰简洁，可维护性好。
VC++ builds its exception handling support on top of structured exception handling (SEH) provided by Windows operating system.
https://www.zhihu.com/question/20597909


## 判断程序是死循环还是死锁
① PS 查询 相关进程的PID 
② top -P   PID   查询该进程占用资源情况    主要查看的是  cpu  和 内存  的占用率
（如果CPU占用率高就是死循环， 如果CPU占用率正常，而且内存占用正常，那就是死锁）
如果有问题，就去详分析该进程底下 各个是哪个线程出现的问题
③ top -Hp  PID     该进程底下各线程的CPU、内存占用情况  


## [四种类型转换](/posts/four-kinds-of-cast)

### 讲解一下动态绑定和静态绑定

### 手写string类


### new/delete与malloc/free区别，new的实质，判断new是否成功的方法
operator new里会调用malloc

### malloc() mmap()底层实现


## 结构体中使用指针和对象有哪些好处



### B继承A,且有虚析构函数， A* a = new B; 中若调用虚析构函数，会调用父类A的还是子类B的析构函数



## [C++里好的编码技巧](/posts/good-practice-in-cpp)


## [C++11开始的新特性](/posts/new-from-cpp11)

### 原子操作类
### 智能指针类
### 多线程
### 设计线程池

## 设计模式
### 如何8保证单例模式只有唯一实例，单例模式的多线程安全性。
### 工厂模式优点
### Template Method
定义：定义一个模板结构，将具体内容延迟到子类去实现。
作用：在不改变模板结构的前提下在子类中重新定义模板中的内容。
Inheritance with virtual.

模板方法模式是基于 继承+虚函数

**优点**：
- 提高代码复用性
  
  将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中

- 提高了拓展性
  
  将不同的代码放入不同的子类中，通过对子类的扩展增加新的行为

- 实现了反向控制
  
  通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 & 符合“开闭原则”

**缺点**：

引入了抽象类，每一个不同的实现都需要一个子类来实现，导致类的个数增加，从而增加了系统实现的复杂度。

**应用场景**
- 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现；
- 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复；
- 控制子类的扩展。




# 数据结构与算法
## 数组

## 链表

## 栈

## 队列

## 堆

## 二叉树：二叉搜索树，平衡树，红黑树，

## 红黑书与普通二叉树区别，红黑树自平衡是自动平衡吗，怎么实现自平衡

## B树、B+树

## 哈希表及哈希冲突

## 解决hash冲突的方法,说一下一致性hash

## 快排过程/时间复杂度

## 二分查找

## 回溯法

## 动态规划

## 如何判断两个链表相交？如果两个链表有环怎么办

## 如何给链表排序？时间复杂度O(nlogn),空间复杂度O(1)

## TopK如何用堆排序实现


# 操作系统
## 堆栈的区别

## 有了进程，为什么还要线程

## 多进程与多线程比较

## 孤儿进程与僵尸进程

## 单核机器上写多线程，是否要考虑加锁

## 线程间共享内存，什么时候用到条件变量，什么时候用到锁

## 线程间同步方式：互斥锁，自旋锁，读写锁，条件变量

## 互斥锁与自旋锁的底层区别

## 死锁及避免

## 线程上下文切换的流程

## 进程上下文切换的流程

## 进程的调度算法

## 缓冲区溢出漏洞

## free()入参是void*,如何知道大小

## 内存碎片是什么？有几种形式，产生的原因是什么

## 字节序，如何转化

## 协程

## 阻塞IO，非阻塞IO。

## 同步，异步

## [静态链接与动态链接的过程](https://zhuanlan.zhihu.com/p/149235029)

## 虚拟内存的概念

## MMU地址翻译的具体流程

## 缺页处理过程

## 缺页置换算法：最久未使用，先进先出，最佳置换


# Linux
## 用户态，内核态，来回切换为什么效率低

## Linux进程间通信方式
PIPE,FIFO,消息队列，信号量，共享内存，socket

## 管道与消息队列对比

## fork进程的底层：读时共享，写时复制

## fork, wait, exec

# [gdb](/posts/gdb)


# 业务

## 如何设计一个车辆管理系统

## 代码优化怎么做的，重构从哪些方面考虑

## 对AI框架的思考
