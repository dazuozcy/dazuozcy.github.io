---
layout: post
title: "Overview"
author: dazuo
date: 2021-06-10 10:33:00 +0800
categories: [overview]
tags: [overview]
math: true
mermaid: true
sidebar: auto
---

- 基本原理：设计这个特性是为了帮助解决哪类问题？其设计原理是什么？它有什么根本的局限？
- 规范：它该如何定义？
- 例子：当单独使用这个特性或与其他特性组合使用时，如何用好它？其中的关键技术和习惯用法是怎样的？在程序的可维护性和性能方面是否有一些隐含的问题？


# C++

## 基础

### `C++`和`C`区别
C++从C发展而来，保留了C的绝大部分特性作为子集。

#### **设计理念**

C++的设计理念是同时提供：
- 将内置操作和内置类型直接映射到硬件，从而提供高效的内存利用和高效的底层操作
- 灵活且低开销的抽象机制，使得用户自定义类型在各方面与内置类型相当。

C++支持4种程序设计风格：
- 过程式程序设计
- 数据抽象：接口的设计与实现细节隐藏。
- 面向对象程序设计，`C`也可以通过一些技术模拟`OOP`，《Object-Oriented Programming With ANSI-C》，但这并不是语言本身的一部分。
- 泛型程序设计


#### **应用**

#### **语义**
C++对某些关键词的语义进行了扩展。如`struct`：在`C`中，`struct`仅仅表示一堆数据的聚合，没有`class-like features`: 没有方法，没有构造函数，没有基类。·C++·继承了`struct`关键字，然后扩展了语义。


### `C++`里`struct`与`class`区别
成员的默认访问控制权限不同，在`struct`中是`public`，在`class`中是`private`.
何时用`struct`,何时用`class`：
- use struct for POD(plain-old-data) structures without any class-like features.
- Use class when you make use of feathers such as private or protected members, non-default constructors and operators, etc.


### 理解面向对象的三大特性：封装，继承，多态

### 类的访问权限：`private`, `protected`, `public`
- `public`：可以被该类中的函数、友元函数、子类的函数访问，也可以由该类的对象访问；
- `protected`：可以被该类中的函数、友元函数、子类的函数访问，但不可以由该类的对象访问；
- `private`：可以被该类中的函数、友元函数访问，但不可以由子类的函数、该类的对象访问。

## [STL](/posts/stl)

## [智能指针](/posts/smart-pointers)

### 构造函数-析构函数

### 构造函数，析构函数简单讲述下

### 构造函数初始化列表与构造函数体内复制的区别

### 构造函数是否可以放到private里面

### 构造函数，析构函数是否可以为虚函数

### 平凡构造函数，非平凡构造函数

### 移动构造函数和拷贝构造函数对比

### 析构函数不加virtual会发生什么，原理

### 深拷贝与浅拷贝区别

### 赋值函数，拷贝函数

### C++编译过程

### 内存分区：全局区、堆区、栈区、常量区、代码区

### 空class有哪些函数，空class大小

### 变量声明，定义区别

### 指针vs引用

### 手写string类

### 手写深拷贝，动态分配内存

### 虚函数作用，什么是纯虚函数，虚函数可以是静态的吗

### 静态函数，虚函数区别

### 虚函数的底层机制，虚函数指针何时生成，在多继承下怎样。虚函数表，存在哪

### 数组对象怎么析构，怎么释放

### 虚表布局，菱形继承

### 介绍多态，是怎么实现的

### 虚函数实现动态多态的原理

### 运行时多态，编译时多态（动态多态，静态多态（重载，重写，模板））

### 类的内存布局

### 继承的底层原理

### 内存溢出与内存泄漏的情况

### 野指针产生与避免

### extern关键字：修饰全局变量

### static关键字：修饰局部变量，全局变量，类中成员变量、类中成员函数

### const关键字：修饰变量，指针，类对象、类中成员函数

### volatile关键字：避免编译器指令优化

### 如何用C来实现抛出捕获异常

### 判断程序是死循环还是死锁

### static_cast, dynamic_cast, const_cast, reinterpret_cast区别

### 写一个拷贝构造函数？为什么引用传递而不是值传递

### new/delete与malloc/free区别，new的实质，判断new是否成功的方法
operator new里会调用malloc

### malloc() mmap()底层实现


### 结构体中使用指针和对象有哪些好处

### 讲解一下动态绑定和静态绑定

### B继承A,且有虚析构函数， A* a = new B; 中若调用虚析构函数，会调用父类A的还是子类B的析构函数

### 类指针如何用C++转换类别，如A* a如何转换到B*，是否所有的指针都可用dynamic_cast进行转换。

### RAII与pimpl惯用法

### C++里好的编码技巧
#### 模板特化
- 允许某些形式的优化
- 减少代码膨胀

#### Expression Template，奇异递归模板模式CRTP

### C++11新特性知道哪些
#### std::is_same与std::decay
std::is_same<Type_a, Type_b>::value, 可以用于模板参数检查。严格判断类型是否一致(int, int&, const int, const int& 都不是同一种类型)。int和signed int是同一种。char和signed char不是同一种。char和unsigned char也不是同一种。
   如果不需要如此严格的校验,可以利用std::decay.
std::is_same<typename std::decay<Type_a>::type, Type_b>::value,
这个检查对于int, int&, int&&, const int&，会判断是同一种类型；int[2]与int*是同种类型， int(int)与int(*)(int)是同种类型。

#### auto与decltype
1. C++是一种强类型语言，声明变量时必须明确指出其类型。
2. 实践中，有时人工很难推断出某个表达式值的类型，并且类型的名字可能会很长，尤其在泛型编程里。
为了解决这个问题，C++11重新定义了auto的语义(以前是用于声明自动变量)，其核心在于类型推导(type deduction)，让编译器在编译期（非运行期）推导出表达式的类型。
auto主要有2个用途：
1. 在变量声明时，根据初始化表达式自动推导该变量的类型。
2. 在声明函数时，作为函数返回值的占位符。
在第2个用途中，auto主要与decltype(内置函数，返回参数的声明类型)配合使用，作为返回值类型后置时的占位符。此时，auto不表示自动类型检测，仅表示后置返回值的语法的一部分。
从C++14开始，例子中的 ->decltype(t+u)就不再需要，可以去掉了。
[注意事项]:(https://veitchkyrie.github.io/2020/02/19/C++-11-auto%E5%85%B3%E9%94%AE%E5%AD%97/)

#### for_each
一种STL泛型算法
```cpp
template<class InputIterator, class Function>
  Function for_each(InputIterator first, InputIterator last, Function fn)
{
  while (first!=last) {
    fn (*first);
    ++first;
  }
  return fn;      // or, since C++11: return move(fn);
}
// fn是unary function.
```

#### nullptr
#### std::forward, std::move, 右值，右值引用，移动构造函数
#### emplace_back(), push_back()
#### lamda表达式
#### std::bind， std::function

#### 统一的类成员初始化方法与std::initializer_list
#### 注解标签（attributes）
#### final, override,=default,=delete语法
#### range-based循环语法
#### 结构化绑定
#### stl容器新增的实用方法
#### std::thread
#### 线程局部存储thread_local
#### 线程同步原语std::mutex, std::condition_variable
#### 原子操作类
#### 智能指针类
#### 多线程
#### 设计线程池

## 设计模式
### 如何8保证单例模式只有唯一实例，单例模式的多线程安全性。
### 工厂模式优点

# Python

## python的set()底层是什么数据结构
hash表

## python装饰器作用

## 提高python效率的方法
pythonic


# 数据结构与算法
## 数组

## 链表

## 栈

## 队列

## 堆

## 二叉树：二叉搜索树，平衡树，红黑树，

## 红黑书与普通二叉树区别，红黑树自平衡是自动平衡吗，怎么实现自平衡

## B树、B+树

## 哈希表及哈希冲突

## 解决hash冲突的方法,说一下一致性hash

## 快排过程/时间复杂度

## 二分查找

## 回溯法

## 动态规划

## 如何判断两个链表相交？如果两个链表有环怎么办

## 如何给链表排序？时间复杂度O(nlogn),空间复杂度O(1)

## TopK如何用堆排序实现

# 操作系统
## 堆栈的区别

## 有了进程，为什么还要线程

## 多进程与多线程比较

## 孤儿进程与僵尸进程

## 单核机器上写多线程，是否要考虑加锁

## 线程间共享内存，什么时候用到条件变量，什么时候用到锁

## 线程间同步方式：互斥锁，自旋锁，读写锁，条件变量

## 互斥锁与自旋锁的底层区别

## 死锁及避免

## 线程上下文切换的流程

## 进程上下文切换的流程

## 进程的调度算法

## 缓冲区溢出漏洞

## free()入参是void*,如何知道大小

## 内存碎片是什么？有几种形式，产生的原因是什么

## 字节序，如何转化

## (struct)内存字节对齐，为什么要字节对齐，什么因素影响字节对齐，可以1字节对齐吗

## 协程

## 阻塞IO，非阻塞IO。

## 同步，异步

## 静态链接与动态链接的过程

## 虚拟内存的概念

## MMU地址翻译的具体流程

## 缺页处理过程

## 缺页置换算法：最久未使用，先进先出，最佳置换

# Linux
## 用户态，内核态，来回切换为什么效率低

## Linux进程间通信方式
PIPE,FIFO,消息队列，信号量，共享内存，socket

## 管道与消息队列对比

## fork进程的底层：读时共享，写时复制

## fork, wait, exec

# [gdb](/posts/gdb)


# 业务

## 如何设计一个车辆管理系统

## 代码优化怎么做的，重构从哪些方面考虑