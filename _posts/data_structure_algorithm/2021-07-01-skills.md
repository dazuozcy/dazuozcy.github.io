---
layout: post
title: "技巧"
author: dazuo
date: 2020-07-01 20:19:00 +0800
categories: [数据结构与算法]
tags: [Data Structure]
math: true
mermaid: true
---

# 数字处理

这种还需要考虑各种corner case. 面向用例编程。

[7. 整数反转](https://leetcode-cn.com/problems/reverse-integer/)

[9. 回文数](https://leetcode-cn.com/problems/palindrome-number/)

[50. Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)

[66. 加一](https://leetcode-cn.com/problems/plus-one/)

[67. 二进制求和](https://leetcode-cn.com/problems/add-binary/)

[136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

[137. 只出现一次的数字 II](https://leetcode-cn.com/problems/single-number-ii/)

[191. 位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/)



# 模拟法

[6. Z 字形变换](https://leetcode-cn.com/problems/zigzag-conversion/)

[48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/)

[54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix)

[57. 插入区间](https://leetcode-cn.com/problems/insert-interval/)

[59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)



# 双指针

[11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

[19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

[26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

[27. 移除元素](https://leetcode-cn.com/problems/remove-element/)

[28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)

[42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

[61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)

[75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)

[88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

[125. 验证回文串](https://leetcode-cn.com/problems/valid-palindrome/)

[141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

[142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

[151. 翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)



# 滑动窗口

所谓滑动窗口，就是不断地调节子序列的起始位置和终止位置，从而得出想要的结果。

实现滑动窗口，主要确定如下三点：

- 窗口内是什么？
- 如何移动窗口的起始位置？
- 如何移动窗口的结束位置？

[3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

[209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

针对本题：

- 窗口内：就是满足其和`≥s`的长度连续子数组
- 窗口起始位置如何移动：若当前窗口的值＞s了，窗口起始位置就要向前移动(即缩小窗口的大小)。可以通过while循环更新左指针。
- 窗口结束位置如何移动：窗口的结束位置就是遍历数组的指针。

[1423. 可获得的最大点数](https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/)



# 中心扩展

[5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

[647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)



# 序列带优先级排序

比如，(w1,h1), (w2, h2), (w3, h3), (w4, h4)

对w按照升序排列，对h按照降序排列。

[354. 俄罗斯套娃信封问题](https://leetcode-cn.com/problems/russian-doll-envelopes/)

1. 首先将所有的信封按照ww值第一关键字升序，hh值第二关键字降序进行排列
2. 随后就可以忽略ww维度，求出hh维度的最长严格递增子序列，其长度即为答案。

[406. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)



# 前(后)缀和/前(后)缀积/差分数组

一维数组前缀和

二维数组前缀和

[238. 除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/)



## 差分数组

前缀和的应用场景，需要对某个区间频繁查询累计和，避免每次查询都遍历这个区间。

差分数组的应用场景，需要对某个区间频繁加或减某一值，避免每次都遍历这个区间。区间变端点。

[798. 得分最高的最小轮调](https://leetcode-cn.com/problems/smallest-rotation-with-highest-score/)

[1109. 航班预订统计](https://leetcode-cn.com/problems/corporate-flight-bookings/)



# 区间类问题

[56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

[57. 插入区间](https://leetcode-cn.com/problems/insert-interval/)

[435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)

[452. 用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)



# 前缀最小值

[2016. 增量元素之间的最大差值](https://leetcode-cn.com/problems/maximum-difference-between-increasing-elements/)

当固定`j`时，选择的下标`i`一定是满足`0 ≤ i < j` 并且`nums[i]`最小的那个`i`。因此可以使用循环对`j`进行遍历，同时维护 `nums[0..j−1]`的前缀最小值，记为`premin`。这样一来：

- 如果`nums[i] > premin`，那么就用`nums[i]−premin`对答案进行更新；

- 否则，用`nums[i]`来更新前缀最小值`premin`。

```cpp
class Solution {
public:
    int maximumDifference(vector<int>& nums) {
        int n = nums.size();
        int ans = -1;
        int pre_min = nums[0];
        for (int i = 1; i < n; ++i) {
            if (nums[i] > premin) {
                ans = max(ans, nums[i] - pre_min);
            } else {
                pre_min = nums[i];
            }
        }
        return ans;
    }
};
```

有了上面的基础，理解下面的这题就稍微轻松点

[1014. 最佳观光组合](https://leetcode-cn.com/problems/best-sightseeing-pair/)



