<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="Introduction to openMP" /><meta name="author" content="dazuo" /><meta property="og:locale" content="en_US" /><meta name="description" content="这是一门非常优秀的OpenMP入门教程，讲解人Tim Mattson也曾参与过OpenMP的开发。" /><meta property="og:description" content="这是一门非常优秀的OpenMP入门教程，讲解人Tim Mattson也曾参与过OpenMP的开发。" /><link rel="canonical" href="https://dazuozcy.github.io/posts/introdution-to-openmp-intel/" /><meta property="og:url" content="https://dazuozcy.github.io/posts/introdution-to-openmp-intel/" /><meta property="og:site_name" content="zuo" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-07-03T20:19:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Introduction to openMP" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"dazuo"},"dateModified":"2021-10-10T16:59:30+08:00","datePublished":"2020-07-03T20:19:00+08:00","description":"这是一门非常优秀的OpenMP入门教程，讲解人Tim Mattson也曾参与过OpenMP的开发。","headline":"Introduction to openMP","mainEntityOfPage":{"@type":"WebPage","@id":"https://dazuozcy.github.io/posts/introdution-to-openmp-intel/"},"url":"https://dazuozcy.github.io/posts/introdution-to-openmp-intel/"}</script><title>Introduction to openMP | zuo</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="zuo"><meta name="application-name" content="zuo"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" as="script"> <script async src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://cdn.jsdelivr.net/gh/cotes2020/chirpy-images/commons/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">zuo</a></div><div class="site-subtitle font-italic">感谢永远有歌把心境道破</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/dazuozcy" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['dazuozcy','163.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Introduction to openMP</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Introduction to openMP</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> dazuo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Fri, Jul 3, 2020, 8:19 PM +0800" prep="on" > Jul 3, 2020 <i class="unloaded">2020-07-03T20:19:00+08:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sun, Oct 10, 2021, 4:59 PM +0800" prefix="Updated " > Oct 10, 2021 <i class="unloaded">2021-10-10T16:59:30+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="6827 words">37 min</span></div></div><div class="post-content"><p><a href="https://www.bilibili.com/video/BV1SW411s7ST?spm_id_from=333.999.0.0">这是</a>一门非常优秀的<code class="language-plaintext highlighter-rouge">OpenMP</code>入门教程，讲解人<code class="language-plaintext highlighter-rouge">Tim Mattson</code>也曾参与过<code class="language-plaintext highlighter-rouge">OpenMP</code>的开发。</p><h1 id="1-概述">1. 概述</h1><p>课程是<code class="language-plaintext highlighter-rouge">简洁的lectures</code> + <code class="language-plaintext highlighter-rouge">简短的execises</code>的方式，讲究边学边练边掌握。</p><p>课程由五大模块组成，每个模块由一系列单元和讨论组成：</p><ul><li><code class="language-plaintext highlighter-rouge">Getting Started with OpenMP</code><li><code class="language-plaintext highlighter-rouge">The Core Features of OpenMP</code><li><code class="language-plaintext highlighter-rouge">Working with OpenMP</code><li><code class="language-plaintext highlighter-rouge">Advanced OpenMP Topics</code><li><code class="language-plaintext highlighter-rouge">Recapitulation</code></ul><p>总共<code class="language-plaintext highlighter-rouge">27</code>个lecture。</p><h1 id="2-并行编程介绍-1">2. 并行编程介绍-1</h1><p>摩尔定律说集成电路上可容纳的晶体管数量大约每18个月便会增加一倍。芯片上更多的晶体管数量带来了更优秀的性能，作者认为以前程序的性能来自于芯片硬件。你可以随心所欲的写你的软件，不用考虑性能，把性能留给了芯片硬件。更先进(晶体管数量更多)的芯片，更优秀的性能。</p><p>但是有一点不得不考虑，那就是功耗。根据<code class="language-plaintext highlighter-rouge">Intel</code>的研究，功耗和性能有这样一个拟合关系$power=perf^{1.74}$。</p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1086 542'%3E%3C/svg%3E" data-proofer-ignore data-src="../../img/openMP/introduction-to-openmp-intel/comparison-between-two-archs.png" alt="image" width="1086" height="542" /></p><div class="table-wrapper"><table><thead><tr><th>单核架构<th style="text-align: center">多核架构<tbody><tr><td>Capacitance = C <br /> Voltage = V <br />Frequency = F <br />Power = $CV^{2F}$<td style="text-align: center">Capacitance = 2.2C <br /> Voltage = 0.6V <br />Frequency = 0.5F <br />Power = $0.396CV^{2F}$</table></div><p>对比可以看出多核架构使我们能够以更低的频率完成相同的工作，同时节省大量的功耗。</p><h1 id="3-并行编程介绍-2">3. 并行编程介绍-2</h1><h2 id="并发-vs-并行">并发 vs. 并行</h2><div class="table-wrapper"><table><thead><tr><th>并发<th style="text-align: left">并行<tbody><tr><td>系统中多个任务同时在<strong>逻辑上</strong>处于活动状态<td style="text-align: left">系统中多个任务同时在<strong>实际上</strong>处于活动状态</table></div><div class="table-wrapper"><table><thead><tr><th>并发应用<th>并行应用<tbody><tr><td>根据应用的语义，计算在<strong>逻辑上</strong>同时执行的一种应用程序。<br />这个问题基本上是同时发生的。<td>一种应用程序，其计算<strong>实际上</strong>是同时执行的<br />以便在更短的时间内计算问题<br />问题本身可以串行描述，并不需要并发性。</table></div><h2 id="openmp">OpenMP</h2><ul><li>用于编写<strong>多线程应用</strong>的<code class="language-plaintext highlighter-rouge">API</code>。<li>为<strong>并行应用</strong>程序员提供的一组编译器指令和库方法。<li>极大简化了<code class="language-plaintext highlighter-rouge">Fortran</code>，<code class="language-plaintext highlighter-rouge">C/C++</code><strong>多线程程序</strong>的编写。</ul><h3 id="openmp解决方案栈">OpenMP解决方案栈</h3><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1086 542'%3E%3C/svg%3E" data-proofer-ignore data-src="../../img/openMP/introduction-to-openmp-intel/openmp-solution-stack.png?raw=true" alt="OpenMP solution stack" width="1086" height="542" /></p><h3 id="openmp核心语法">OpenMP核心语法</h3><ul><li>OpenMP中大部分constructs是compiler directives.<li><code class="language-plaintext highlighter-rouge">#pragma omp construct [clause [clause]...]</code><li><code class="language-plaintext highlighter-rouge">#pragma omp parallel num_threads(4)</code><li><code class="language-plaintext highlighter-rouge">#include &lt;omp.h&gt;</code><li>大部分<code class="language-plaintext highlighter-rouge">OpenMP</code> <code class="language-plaintext highlighter-rouge">constructs</code>作用于<code class="language-plaintext highlighter-rouge">Structured Block</code>.<li><code class="language-plaintext highlighter-rouge">Structured Block</code>: 一个或多个语句块，顶部有一个入口点，底部有一个出口点。</ul><h1 id="4-使用openmp编译hello-world">4. 使用OpenMP编译(Hello World)</h1><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>gcc <span class="nt">-fopenmp</span> foo.c

<span class="nb">export </span><span class="nv">OMP_NUM_THREADS</span><span class="o">=</span>4

./a.out
</pre></table></code></div></div><h2 id="exercise-1">Exercise 1</h2><p><strong>Verify that your OMP environment works, write a multithreaded program that prints “Hello World”</strong>.</p><h1 id="5-讨论1-hello-world线程如何工作的">5. 讨论1-<code class="language-plaintext highlighter-rouge">Hello World</code>、线程如何工作的</h1><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;omp.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="cp">#pragma omp parallel
</span>  <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ID</span> <span class="o">=</span> <span class="n">omp_get_thread_num</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"hello(%d)"</span><span class="p">,</span> <span class="n">ID</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">" world(%d) </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ID</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">#pragma omp parallel</code> 申请默认数量的线程。 <code class="language-plaintext highlighter-rouge">omp_get_thread_num()</code> 返回每个线程的唯一标识。范围是<code class="language-plaintext highlighter-rouge">[0,N]</code>。</p><h2 id="共享内存计算机">共享内存计算机</h2><p>任何由共享一份地址空间的多个处理单元组成的计算机。有两类：</p><ul><li><p>对称多处理器(<code class="language-plaintext highlighter-rouge">SMP</code>)</p><p>一个共享地址空间，每个处理器访问地址空间的时间消耗是相同的，操作系统以相同的方式处理每个处理器。</p><li><p>非统一地址空间多处理器(<code class="language-plaintext highlighter-rouge">NUMA</code>)</p><p>不同的内存区域具有不同的访问成本。想像将内存分为“近”内存和“远”内存。</p></ul><h2 id="openmp概览">OpenMP概览</h2><ul><li>OpenMP是一种多线程共享地址模型。<li>线程间通过共享变量进行通信。<li>意外共享数据会导致竞争状况。<li>竞争条件：当程序的结果随着线程调度的不同而改变时。<li>要控制竞争条件，请使用同步来保护数据冲突。<li>同步是昂贵的。</ul><h1 id="6-创建线程pi程序">6. 创建线程(<code class="language-plaintext highlighter-rouge">Pi</code>程序)</h1><h2 id="fork-join并行"><code class="language-plaintext highlighter-rouge">fork-join</code>并行</h2><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 542 242'%3E%3C/svg%3E" data-proofer-ignore data-src="../../img/openMP/fork-join.png" alt="fork-join-parallellism" width="542" height="242" /></p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 542 242'%3E%3C/svg%3E" data-proofer-ignore data-src="../../img/openMP/introduction-to-openmp-intel/openmp-fork-join-parallellism.png" alt="fork-join" width="542" height="242" /></p><p>在某个时刻<code class="language-plaintext highlighter-rouge">fork</code>若干个线程，在另外某个时刻<code class="language-plaintext highlighter-rouge">join</code>到一起。下面是一个简单的例子：</p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 542 242'%3E%3C/svg%3E" data-proofer-ignore data-src="../../img/openMP/introduction-to-openmp-intel/openmp-execution-model-example.png?raw=true" alt="openmp-execution-model-example" width="542" height="242" /></p><h2 id="exercise-2">Exercise 2</h2><p><strong>把下面这个串行版本的计算<code class="language-plaintext highlighter-rouge">Pi</code>值的程序改成并行版本</strong>。</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">calc_pi_serial</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">long</span> <span class="n">num_steps</span> <span class="o">=</span> <span class="mh">0x20000000</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">num_steps</span><span class="p">;</span>

    <span class="kt">double</span> <span class="n">start</span> <span class="o">=</span> <span class="n">omp_get_wtime</span><span class="p">(</span> <span class="p">);</span>    
    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_steps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="n">step</span><span class="p">;</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">.</span><span class="mi">0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>    
    <span class="kt">double</span> <span class="n">pi</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">*</span> <span class="n">step</span><span class="p">;</span>
    
    <span class="n">printf</span><span class="p">(</span><span class="s">"pi: %.16g in %.16g secs</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">omp_get_wtime</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
    <span class="c1">// will print "pi: 3.141592653589428 in 5.664520263002487 secs"</span>
<span class="p">}</span>
</pre></table></code></div></div><h1 id="7-讨论-2-简单的pi程序及为什么性能如此差">7. 讨论 2-简单的<code class="language-plaintext highlighter-rouge">Pi</code>程序及为什么性能如此差</h1><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="cp">#define NUM_THREADS 2
</span>
<span class="kt">void</span> <span class="nf">calc_pi_omp_v1</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">long</span> <span class="n">num_steps</span> <span class="o">=</span> <span class="mh">0x20000000</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">sum</span><span class="p">[</span><span class="n">NUM_THREADS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span> <span class="p">};</span>
    <span class="kt">double</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">num_steps</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">nthreads</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">start</span> <span class="o">=</span> <span class="n">omp_get_wtime</span><span class="p">(</span> <span class="p">);</span>    
    
    <span class="n">omp_set_num_threads</span><span class="p">(</span><span class="n">NUM_THREADS</span><span class="p">);</span>
    <span class="cp">#pragma omp parallel
</span>    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">omp_get_thread_num</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">nthrds</span> <span class="o">=</span> <span class="n">omp_get_num_threads</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// master thread</span>
            <span class="n">nthreads</span> <span class="o">=</span> <span class="n">nthrds</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_steps</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">nthrds</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="n">step</span><span class="p">;</span>
            <span class="n">sum</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">.</span><span class="mi">0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>  
    <span class="p">}</span>
    <span class="kt">double</span> <span class="n">pi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nthreads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pi</span> <span class="o">+=</span> <span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">step</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">printf</span><span class="p">(</span><span class="s">"pi: %.16g in %.16g secs</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">omp_get_wtime</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>上述并行版本可以得到正确的结果，但是当<code class="language-plaintext highlighter-rouge">NUM_THREADS</code>的值配置的更大的时候，耗时反而增加了。</p><p>原因是<strong>伪共享</strong>(<strong>false sharing</strong>)。</p><h2 id="伪共享">伪共享</h2><p>If independent data elements happen to sit on the same cache line, each update will cause the cache lines to “slosh back and forth” between threads.</p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 542 242'%3E%3C/svg%3E" data-proofer-ignore data-src="../../img/openMP/introduction-to-openmp-intel/openmp-false-sharing.png?raw=true" alt="false sharing" width="542" height="242" /></p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="cp">#define NUM_THREADS 4
#define PAD 8 // assume 64 byte L1 cache line size
</span><span class="kt">void</span> <span class="nf">calc_pi_omp_v1</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">long</span> <span class="n">num_steps</span> <span class="o">=</span> <span class="mh">0x20000000</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">sum</span><span class="p">[</span><span class="n">NUM_THREADS</span><span class="p">][</span><span class="n">PAD</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span> <span class="p">};</span>
    <span class="kt">double</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">num_steps</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">nthreads</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">start</span> <span class="o">=</span> <span class="n">omp_get_wtime</span><span class="p">(</span> <span class="p">);</span>    
    
    <span class="n">omp_set_num_threads</span><span class="p">(</span><span class="n">NUM_THREADS</span><span class="p">);</span>
    <span class="cp">#pragma omp parallel
</span>    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">omp_get_thread_num</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">nthrds</span> <span class="o">=</span> <span class="n">omp_get_num_threads</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">nthreads</span> <span class="o">=</span> <span class="n">nthrds</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_steps</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">nthrds</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="n">step</span><span class="p">;</span>
            <span class="n">sum</span><span class="p">[</span><span class="n">id</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">.</span><span class="mi">0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>  
    <span class="p">}</span>
    <span class="kt">double</span> <span class="n">pi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nthreads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pi</span> <span class="o">+=</span> <span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">step</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">printf</span><span class="p">(</span><span class="s">"pi: %.16g in %.16g secs</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">omp_get_wtime</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>上述解决方案中通过增加<code class="language-plaintext highlighter-rouge">[PAD]</code>这一维，来保证<code class="language-plaintext highlighter-rouge">sum[nthreads]</code>中连续的元素存在于不同的<code class="language-plaintext highlighter-rouge">cache line</code>上。</p><h1 id="8-同步再看pi程序">8. 同步(再看<code class="language-plaintext highlighter-rouge">Pi</code>程序)</h1><ul><li>OpenMP是一种多线程共享地址模型。<li>理解共享数据会导致竞争状况。<li>要控制竞争条件，请使用同步来保护数据冲突。<li>改变数据的访问方式来最小化对同步的需求。</ul><h3 id="高层同步">高层同步:</h3><ul><li><code class="language-plaintext highlighter-rouge">critical</code>(Mutual exclusion)<li><code class="language-plaintext highlighter-rouge">atomic</code><li><code class="language-plaintext highlighter-rouge">barrier</code><li><code class="language-plaintext highlighter-rouge">ordered</code></ul><h3 id="底层同步">底层同步:</h3><ul><li><code class="language-plaintext highlighter-rouge">flush</code><li><code class="language-plaintext highlighter-rouge">locks</code>(both simple and nested)</ul><h2 id="critical原语"><code class="language-plaintext highlighter-rouge">critical</code>原语</h2><p>在某一时刻，只有<code class="language-plaintext highlighter-rouge">1</code>个线程会执行<code class="language-plaintext highlighter-rouge">critical</code> 块，不会有多个线程同时执行。</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kt">float</span> <span class="n">res</span><span class="p">;</span>

<span class="cp">#pragma omp parallel
</span><span class="p">{</span>
  <span class="kt">float</span> <span class="n">B</span><span class="p">;</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="n">nthrds</span><span class="p">;</span>
  <span class="n">id</span> <span class="o">=</span> <span class="n">omp_get_thread_num</span><span class="p">();</span>
  <span class="n">nthrds</span> <span class="o">=</span> <span class="n">omp_get_num_threads</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">id</span><span class="p">,</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">niters</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">nthrds</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">big_job</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="cp">#pragma omp critical
</span>    <span class="n">res</span> <span class="o">+=</span> <span class="n">consume</span><span class="p">(</span><span class="n">B</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="atomic原语"><code class="language-plaintext highlighter-rouge">atomic</code>原语</h2><p><code class="language-plaintext highlighter-rouge">atomic</code>里的语句只能是下列形式中的一种。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>x binop = expr
   x++
   ++x
   x--
   --x

x is an lvalue of scalar type and binop is a non-overloaded built in operator.
</pre></table></code></div></div><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="cp">#pragma omp parallel
</span><span class="p">{</span>
    <span class="kt">double</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">B</span><span class="p">;</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">DOIT</span><span class="p">();</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">big_ugly</span><span class="p">(</span><span class="n">B</span><span class="p">);</span>

<span class="cp">#pragma omp atomic
</span>    <span class="n">X</span> <span class="o">+=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="exercise-3">Exercise 3</h2><p><strong>修改<code class="language-plaintext highlighter-rouge">Exercise 2</code>中的代码，来解决由于<code class="language-plaintext highlighter-rouge">sum</code>数组引入的<code class="language-plaintext highlighter-rouge">false sharing</code>问题</strong>。</p><h1 id="9-讨论3-同步的开销和消除伪共享">9. 讨论3-同步的开销和消除伪共享</h1><p>在<code class="language-plaintext highlighter-rouge">7</code>的解决方案中，通过增加<code class="language-plaintext highlighter-rouge">[PAD]</code>这一维，来保证<code class="language-plaintext highlighter-rouge">sum[nthreads]</code>中连续的元素存在于不同的<code class="language-plaintext highlighter-rouge">cache line</code>上，从而消除了伪共享。</p><p>但是<code class="language-plaintext highlighter-rouge">cache line</code>的<code class="language-plaintext highlighter-rouge">size</code>在不同机器上可能不一样，<code class="language-plaintext highlighter-rouge">7</code>的解决方案就不具有可移植性，并且不够优雅。</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">calc_pi_omp_v2</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">long</span> <span class="n">num_steps</span> <span class="o">=</span> <span class="mh">0x20000000</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">step</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">num_steps</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">nthreads</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">start</span> <span class="o">=</span> <span class="n">omp_get_wtime</span><span class="p">(</span> <span class="p">);</span>    
    <span class="kt">double</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="n">omp_set_num_threads</span><span class="p">(</span><span class="n">NUM_THREADS</span><span class="p">);</span>
    <span class="cp">#pragma omp parallel
</span>    <span class="p">{</span>
        <span class="c1">// sum需要是线程私有的，不能放在并行域外，否则结果不正确，切耗时更长</span>
        <span class="kt">double</span> <span class="n">sum</span><span class="p">;</span>  
        <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">omp_get_thread_num</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">nthrds</span> <span class="o">=</span> <span class="n">omp_get_num_threads</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">nthreads</span> <span class="o">=</span> <span class="n">nthrds</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">id</span><span class="p">,</span> <span class="n">sum</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_steps</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">nthrds</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">step</span><span class="p">;</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="mf">4.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>  
    <span class="cp">#pragma omp critical
</span>        <span class="n">pi</span> <span class="o">+=</span> <span class="n">sum</span> <span class="o">*</span> <span class="n">step</span><span class="p">;</span>      
    <span class="cm">/*// 下面这3行的写法跟上面2行的效果类似
      sum *= step;
    #pragma omp atomic
      pi += sum;  
    */</span>  
    <span class="p">}</span>
    
    <span class="n">printf</span><span class="p">(</span><span class="s">"pi: %.16g in %.16g secs</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">omp_get_wtime</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h1 id="10-并行化循环让pi程序简单-1">10. 并行化循环(让<code class="language-plaintext highlighter-rouge">Pi</code>程序简单)-1</h1><h2 id="worksharing">Worksharing</h2><ul><li>Loop Construct<li>Sections/Section Construct<li>Single Construct<li>Task Construct</ul><h2 id="loop-worksharing-construct">Loop Worksharing Construct</h2><h3 id="schedule-clause">Schedule Clause</h3><p><code class="language-plaintext highlighter-rouge">schedule</code>子句影响循环迭代映射到线程的方式。</p><ul><li><code class="language-plaintext highlighter-rouge">schedule(static [, chunk])</code>: 迭代空间被划分为<code class="language-plaintext highlighter-rouge">chunk</code>大小的块，块以<code class="language-plaintext highlighter-rouge">round-robin</code>方式分配给线程。若未指定块：#线程块。<li><code class="language-plaintext highlighter-rouge">schedule(dynamic [, chunk])</code>: 迭代空间分为<code class="language-plaintext highlighter-rouge">chunk</code>大小（未指定：1）的块，块按线程完成之前块的顺序调度到线程。<li><code class="language-plaintext highlighter-rouge">schedule(guided [, chunk])</code>: 与动态相似，但块大小从实现定义的值开始，然后以指数形式减小到块。<li><code class="language-plaintext highlighter-rouge">schedule(runtime)</code>: 从<code class="language-plaintext highlighter-rouge">OMP_SCHEDULE</code>环境变量（或运行时库）获取调度和块大小。<li><code class="language-plaintext highlighter-rouge">schedule(auto)</code>: 调度策略在运行时选择（不必是上述任何一项）。</ul><h4 id="何时使用schedule-clause">何时使用schedule clause</h4><ul><li><p><code class="language-plaintext highlighter-rouge">static</code></p><p>由程序员预先确定。在编译时完成调度，运行时的工作量最小。</p><li><p><code class="language-plaintext highlighter-rouge">dynamic</code></p><p>每次迭代的工作都是不可预测的、高度可变的。运行时的工作量最大。运行时使用复杂调度逻辑。</p></ul><h1 id="11-并行化循环让pi程序简单-2">11. 并行化循环(让<code class="language-plaintext highlighter-rouge">Pi</code>程序简单)-2</h1><ul><li>找到compute-intensive的for循环<li>让每个迭代独立以保证循环可以以任何顺序正确的执行</ul><p>比如下面这段代码片段，<code class="language-plaintext highlighter-rouge">A[i]</code>的值依赖于<code class="language-plaintext highlighter-rouge">j</code>的值，<code class="language-plaintext highlighter-rouge">j</code>的值又依赖于上一次<code class="language-plaintext highlighter-rouge">j</code>的值。这样就导致循环无法并行起来。</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="n">MAX</span><span class="p">];</span>
<span class="n">j</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">j</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">big</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>将<code class="language-plaintext highlighter-rouge">j</code>的计算改造一下，就可以使得当前迭代不再依赖于上一次迭代，就可以并行起来。如下所示：</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="n">MAX</span><span class="p">];</span>
<span class="cp">#pragma omp parallel for
</span><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">big</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="reduction原语"><code class="language-plaintext highlighter-rouge">reduction</code>原语</h2><p>在<code class="language-plaintext highlighter-rouge">reduction</code>操作中，运算符应用于列表中的所有变量。这些变量必须是共享的。</p><ul><li><code class="language-plaintext highlighter-rouge">reduction(operator:list)</code><li><p>结果在相关的<code class="language-plaintext highlighter-rouge">reduction</code>变量中提供。</p><li><p>每个列表变量会产生一份本地副本，根据<code class="language-plaintext highlighter-rouge">op</code>的不同初始化成相应的值。</p><li><p>对本地副本进行更新。</p><li><p>本地副本<code class="language-plaintext highlighter-rouge">reduce</code>成一个值，然后和原始的全局值组合。</p><li>可能的<code class="language-plaintext highlighter-rouge">reduction</code>操作及初始化值： <code class="language-plaintext highlighter-rouge">+ (0)</code>, <code class="language-plaintext highlighter-rouge">* (1)</code>, <code class="language-plaintext highlighter-rouge">- (0)</code>, <code class="language-plaintext highlighter-rouge">&amp; (~0)</code>, <code class="language-plaintext highlighter-rouge">^ (0)</code>, <code class="language-plaintext highlighter-rouge">| (0)</code>, <code class="language-plaintext highlighter-rouge">&amp;&amp; (1)</code>, <code class="language-plaintext highlighter-rouge">|| (0)</code>, <code class="language-plaintext highlighter-rouge">min (最大数)</code>, <code class="language-plaintext highlighter-rouge">max (最小数)</code></ul><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1086 542'%3E%3C/svg%3E" data-proofer-ignore data-src="../../img/openMP/reduction.png" alt="reduction" width="1086" height="542" /></p><h1 id="12-讨论4-pi程序总结">12. 讨论4-<code class="language-plaintext highlighter-rouge">Pi</code>程序总结</h1><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">calc_pi_reduction</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">long</span> <span class="n">num_steps</span> <span class="o">=</span> <span class="mh">0x20000000</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">step</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="n">step</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">num_steps</span><span class="p">;</span>

    <span class="kt">double</span> <span class="n">start</span> <span class="o">=</span> <span class="n">omp_get_wtime</span><span class="p">(</span> <span class="p">);</span>    
<span class="cp">#pragma omp parallel
#pragma omp for reduction(+:sum)
</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_steps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">step</span><span class="p">;</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="mf">4.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>    
    <span class="kt">double</span> <span class="n">pi</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">*</span> <span class="n">step</span><span class="p">;</span>

    <span class="kt">double</span> <span class="n">end</span> <span class="o">=</span> <span class="n">omp_get_wtime</span><span class="p">(</span> <span class="p">);</span>
    
    <span class="n">printf</span><span class="p">(</span><span class="s">"pi: %.16g in %.16g secs</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h1 id="13-barriers和更多constructs">13. Barriers…和更多Constructs</h1><h2 id="barrier原语"><code class="language-plaintext highlighter-rouge">barrier</code>原语</h2><p>线程等待，直到当前组的所有线程都达到屏障。</p><p>所有<code class="language-plaintext highlighter-rouge">worksharing constructs</code>的末尾都包含隐式屏障。</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="cp">#pragma omp parallel
</span><span class="p">{</span>
  <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">omp_get_thread_num</span><span class="p">();</span>
  <span class="n">A</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">big_cal1</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
<span class="cp">#pragma omp barrier
</span>  <span class="n">B</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">big_cal2</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">A</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h1 id="14-openmp中的锁">14. OpenMP中的锁</h1><h3 id="lock方法">Lock方法</h3><ul><li><code class="language-plaintext highlighter-rouge">omp_init_lock()</code><li><code class="language-plaintext highlighter-rouge">omp_set_lock()</code><li><code class="language-plaintext highlighter-rouge">omp_uset_lock()</code><li><code class="language-plaintext highlighter-rouge">omp_destroy_lock()</code><li><code class="language-plaintext highlighter-rouge">omp_test_lock()</code></ul><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="cp">#pragma omp parallel for
</span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NBUCKETS</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">omp_init_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hist_locks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">hist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#pragma omp parallel for
</span><span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NVALS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ival</span> <span class="o">=</span> <span class="n">sample</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">omp_set_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hist_locks</span><span class="p">[</span><span class="n">ival</span><span class="p">]);</span>
      <span class="n">hist</span><span class="p">[</span><span class="n">ival</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
    <span class="n">omp_unset_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hist_locks</span><span class="p">[</span><span class="n">ival</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cp">#pragma omp parallel for
</span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NBUCKETS</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">omp_destroy_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hist_locks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</pre></table></code></div></div><h1 id="15-openmp的运行时库方法">15. OpenMP的运行时库方法</h1><p>运行时库方法</p><ul><li><code class="language-plaintext highlighter-rouge">omp_set_num_threads()</code><li><code class="language-plaintext highlighter-rouge">omp_get_num_threads()</code>，在并行域外调用这个接口，返回值是1<li><code class="language-plaintext highlighter-rouge">omp_get_thread_num()</code><li><code class="language-plaintext highlighter-rouge">omp_get_max_threads()</code><li><code class="language-plaintext highlighter-rouge">omp_in_parallel()</code><li><code class="language-plaintext highlighter-rouge">omp_set_dynamic()</code><li><code class="language-plaintext highlighter-rouge">omp_get_dynamic()</code><li><code class="language-plaintext highlighter-rouge">omp_num_procs()</code></ul><h1 id="16-openmp的环境变量">16. OpenMP的环境变量</h1><ul><li><code class="language-plaintext highlighter-rouge">OMP_NUM_THREADS</code><li><code class="language-plaintext highlighter-rouge">OMP_STACKSIZE</code><li><code class="language-plaintext highlighter-rouge">OMP_WAIT_POLICY</code>，(ACTIVE or PASSIVE)<li><code class="language-plaintext highlighter-rouge">OMP_PROC_BIND</code>，（TRUE or FALSE）</ul><h1 id="17-数据作用域">17. 数据作用域</h1><p>由于OpenMP是基于共享内存的编程模型，所以大部分变量的属性默认是shared，比如static变量、文件作用域的变量。但是并不是一切都是shared，并行域里调用的函数的栈变量是private，语句块里的自动变量是private。基本原则是：Heap is shared, stack is private.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kt">double</span> <span class="n">A</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">index</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="cp">#pragma omp parallel
</span>      <span class="n">work</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>    
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">double</span> <span class="n">A</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="kt">void</span> <span class="nf">work</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">temp</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
<span class="cm">/*
  A, index, count 是shared
  temp是private
*/</span>
</pre></table></code></div></div><h2 id="改变存储属性">改变存储属性</h2><ul><li><code class="language-plaintext highlighter-rouge">shared</code><li><p><code class="language-plaintext highlighter-rouge">private</code></p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>  <span class="kt">void</span> <span class="nf">wrong</span><span class="p">()</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="cp">#pragma omp parallel for private(tmp) //tmp的私有副本是未初始化的
</span>      <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">tmp</span> <span class="o">+=</span> <span class="n">j</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span> <span class="c1">// 会打印全局tmp的值0</span>
  <span class="p">}</span>
</pre></table></code></div></div><li>firstprivate<div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>  <span class="kt">int</span> <span class="n">incr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// incr的私有副本会用全局incr的值0作为初始值，for循环结束后，私有副本会消失</span>
  <span class="cp">#pragma omp parallel for firstprivate(incr) 
</span>  <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span><span class="n">MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">incr</span><span class="o">++</span><span class="p">;</span>
      <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">incr</span><span class="p">;</span>
  <span class="p">}</span>
</pre></table></code></div></div><li>lastprivate<div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>  <span class="kt">void</span> <span class="nf">sq2</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">lastterm</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">double</span> <span class="n">x</span><span class="p">;</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
      <span class="c1">// 最后一次循环（i=N-1）得到的x的值会传给全局x，进而赋给lastterm指针指向的对象</span>
      <span class="cp">#pragma omp parallel for lastprivate(x) 
</span>      <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
          <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
      <span class="p">}</span>
    
      <span class="o">*</span><span class="n">lastterm</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
</pre></table></code></div></div><li>default(private/shared/none)</ul><h3 id="openmp中的作用域-将变量分为shared和private">OpenMP中的作用域: 将变量分为<code class="language-plaintext highlighter-rouge">shared</code>和<code class="language-plaintext highlighter-rouge">private</code>:</h3><ul><li>private-list and shared-list on Parallel Region.<li>private-list and shared-list on Worksharing constructs.<li>General default is shared for Parallel Region, firstprivate for Task.<li>Loop control variables on for-constructs are private.<li>Non-static variables local to Parallel Regions are private.<li><code class="language-plaintext highlighter-rouge">private</code>: A new uninitialuized instance is created for the task or each thread executing the construct.<ul><li><code class="language-plaintext highlighter-rouge">firstprivate</code>: Initialization with the value before encountering the construct<li><code class="language-plaintext highlighter-rouge">lastprivate</code>: Value of last loop iteration is written back to Master</ul><li>静态变量是<code class="language-plaintext highlighter-rouge">shared</code>.</ul><h3 id="全局静态变量的私有化">全局/静态变量的私有化</h3><p>全局/静态变量可以通过<code class="language-plaintext highlighter-rouge">threadprivate</code>原语被私有化。</p><ul><li>One instance is created for each thread<ul><li>before the first parallel region is encountered.<li>instance exists until the program ends<li>does not work (well) with nested parallel region.</ul><li>Based on thread-local storage(TLS)<div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="n">i</span><span class="p">;</span>
<span class="cp">#pragma omp threadprivate(i)
</span></pre></table></code></div></div></ul><h1 id="18-讨论5-调试openmp程序">18. 讨论5-调试OpenMP程序</h1><p>下面是错误版本。</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"omp.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
</span>
<span class="cp">#define NPOINTS 1000
#define MXITR 1000
</span><span class="k">struct</span> <span class="nc">d_complex</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">r</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">d_complex</span> <span class="n">c</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">numoutside</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">testpoint</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="nc">d_complex</span> <span class="n">z</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">iter</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">temp</span><span class="p">;</span>
    
    <span class="n">z</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">iter</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">iter</span><span class="o">&lt;</span><span class="n">MXITR</span><span class="p">;</span> <span class="n">iter</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span><span class="p">.</span><span class="n">r</span><span class="o">*</span><span class="n">z</span><span class="p">.</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">z</span><span class="p">.</span><span class="n">i</span><span class="o">*</span><span class="n">z</span><span class="p">.</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="n">c</span><span class="p">.</span><span class="n">r</span><span class="p">;</span>
        <span class="n">z</span><span class="p">.</span><span class="n">i</span><span class="o">=</span><span class="n">z</span><span class="p">.</span><span class="n">r</span><span class="o">*</span><span class="n">z</span><span class="p">.</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="n">c</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>
        <span class="n">z</span><span class="p">.</span><span class="n">r</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>
        <span class="k">if</span><span class="p">((</span><span class="n">z</span><span class="p">.</span><span class="n">r</span><span class="o">*</span><span class="n">z</span><span class="p">.</span><span class="n">r</span><span class="o">+</span><span class="n">z</span><span class="p">.</span><span class="n">i</span><span class="o">*</span><span class="n">z</span><span class="p">.</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">4.0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">numoutside</span><span class="o">++</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">MandelBrotArea</span><span class="p">()</span>
<span class="p">{</span>    
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">area</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">eps</span> <span class="o">=</span> <span class="mf">1.0e-5</span><span class="p">;</span>
<span class="cp">#pragma omp parallel for default(shared) private(c, eps)
</span>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NPOINTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">NPOINTS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">c</span><span class="p">.</span><span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.0</span> <span class="o">+</span> <span class="mf">2.5</span><span class="o">*</span><span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">NPOINTS</span> <span class="o">+</span> <span class="n">eps</span><span class="p">;</span>
            <span class="n">c</span><span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="mf">1.125</span><span class="o">*</span><span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">j</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">NPOINTS</span> <span class="o">+</span> <span class="n">eps</span><span class="p">;</span>
            <span class="n">testpoint</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="n">area</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="mf">2.5</span><span class="o">*</span><span class="mf">1.125</span> <span class="o">*</span> <span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">NPOINTS</span><span class="o">*</span><span class="n">NPOINTS</span><span class="o">-</span><span class="n">numoutside</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">NPOINTS</span><span class="o">*</span><span class="n">NPOINTS</span><span class="p">);</span>
    <span class="n">error</span><span class="o">=</span><span class="n">area</span><span class="o">/</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">NPOINTS</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"error: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">MandelBrotArea</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>将default设置为none，可以用来调试。</p><div class="language-diff highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="gd">- #pragma omp parallel for default(shared) private(c, eps)
</span><span class="gi">+ #pragma omp parallel for default(none) private(c, eps)
</span></pre></table></code></div></div><p>再进行编译的时候就会error信息：</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>mandelbrot_wrong.cc: In <span class="k">function</span> ‘void MandelBrotArea<span class="o">()</span>’:
mandelbrot_wrong.cc:38:16: error: ‘j’ not specified <span class="k">in </span>enclosing ‘parallel’
         <span class="k">for</span> <span class="o">(</span>j <span class="o">=</span> 0<span class="p">;</span> j &lt; NPOINTS<span class="p">;</span> j++<span class="o">)</span> <span class="o">{</span>
              ~~^~~
mandelbrot_wrong.cc:36:9: error: enclosing ‘parallel’
 <span class="c">#pragma omp parallel for default(none) private(c, eps)</span>
         ^~~
</pre></table></code></div></div><p>下面是正确的版本。</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="cp">#define NPOINTS 1000
#define MXITR 1000
</span><span class="k">struct</span> <span class="nc">d_complex</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">r</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">d_complex</span> <span class="n">c</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">numoutside</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">testpoint</span><span class="p">(</span><span class="k">struct</span> <span class="nc">d_complex</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="nc">d_complex</span> <span class="n">z</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">iter</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">temp</span><span class="p">;</span>
    
    <span class="n">z</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">iter</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">iter</span><span class="o">&lt;</span><span class="n">MXITR</span><span class="p">;</span> <span class="n">iter</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span><span class="p">.</span><span class="n">r</span><span class="o">*</span><span class="n">z</span><span class="p">.</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">z</span><span class="p">.</span><span class="n">i</span><span class="o">*</span><span class="n">z</span><span class="p">.</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="n">c</span><span class="p">.</span><span class="n">r</span><span class="p">;</span>
        <span class="n">z</span><span class="p">.</span><span class="n">i</span><span class="o">=</span><span class="n">z</span><span class="p">.</span><span class="n">r</span><span class="o">*</span><span class="n">z</span><span class="p">.</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="n">c</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>
        <span class="n">z</span><span class="p">.</span><span class="n">r</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>
        <span class="k">if</span><span class="p">((</span><span class="n">z</span><span class="p">.</span><span class="n">r</span><span class="o">*</span><span class="n">z</span><span class="p">.</span><span class="n">r</span><span class="o">+</span><span class="n">z</span><span class="p">.</span><span class="n">i</span><span class="o">*</span><span class="n">z</span><span class="p">.</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">4.0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cp">#pragma omp atomic
</span>            <span class="n">numoutside</span><span class="o">++</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">MandelBrotArea</span><span class="p">()</span>
<span class="p">{</span>    
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">area</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">eps</span> <span class="o">=</span> <span class="mf">1.0e-5</span><span class="p">;</span>
<span class="cp">#pragma omp parallel for default(shared) private(c, j) firstprivate(eps)
</span>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NPOINTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">NPOINTS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">c</span><span class="p">.</span><span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.0</span> <span class="o">+</span> <span class="mf">2.5</span><span class="o">*</span><span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">NPOINTS</span> <span class="o">+</span> <span class="n">eps</span><span class="p">;</span>
            <span class="n">c</span><span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="mf">1.125</span><span class="o">*</span><span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">j</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">NPOINTS</span> <span class="o">+</span> <span class="n">eps</span><span class="p">;</span>
            <span class="n">testpoint</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="n">area</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="mf">2.5</span><span class="o">*</span><span class="mf">1.125</span> <span class="o">*</span> <span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">NPOINTS</span><span class="o">*</span><span class="n">NPOINTS</span><span class="o">-</span><span class="n">numoutside</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">NPOINTS</span><span class="o">*</span><span class="n">NPOINTS</span><span class="p">);</span>
    <span class="n">error</span><span class="o">=</span><span class="n">area</span><span class="o">/</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">NPOINTS</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"error: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>下面是两个版本之间的差异</p><div class="language-diff highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="gh">diff --git a/mandelbrot_wrong.cc b/mandelbrot.cc
index 833155f..e6aadd1 100644
</span><span class="gd">--- a/mandelbrot_wrong.cc
</span><span class="gi">+++ b/mandelbrot.cc
</span><span class="p">@@ -11,7 +11,7 @@</span> struct d_complex {
 struct d_complex c;
 int numoutside = 0;
 
<span class="gd">-void testpoint()
</span><span class="gi">+void testpoint(struct d_complex c)
</span> {
     struct d_complex z;
     int iter;
<span class="p">@@ -23,6 +23,7 @@</span> void testpoint()
         z.i=z.r*z.i*2+c.i;
         z.r=temp;
         if((z.r*z.r+z.i*z.i) &gt; 4.0) {
<span class="gi">+        #pragma omp atomic
</span>             numoutside++;
             break;
         }
<span class="p">@@ -33,12 +34,12 @@</span> void MandelBrotArea()
 {    
     int i, j;
     double area, error, eps = 1.0e-5;
<span class="gd">-#pragma omp parallel for default(shared) private(c, eps)
</span><span class="gi">+#pragma omp parallel for default(shared) private(c, j) firstprivate(eps)
</span>     for (i = 0; i &lt; NPOINTS; i++) {
         for (j = 0; j &lt; NPOINTS; j++) {
             c.r = -2.0 + 2.5*(double)(i) / (double)NPOINTS + eps;
             c.i = 1.125*(double)(j) / (double)NPOINTS + eps;
<span class="gd">-            testpoint();
</span><span class="gi">+            testpoint(c);
</span>         }
     }
</pre></table></code></div></div><p>改动最少的计算<code class="language-plaintext highlighter-rouge">pi</code>的版本:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">calc_pi_reduction</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">long</span> <span class="n">num_steps</span> <span class="o">=</span> <span class="mh">0x20000000</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">step</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="n">step</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">num_steps</span><span class="p">;</span>

    <span class="kt">double</span> <span class="n">start</span> <span class="o">=</span> <span class="n">omp_get_wtime</span><span class="p">(</span> <span class="p">);</span>    
<span class="cp">#pragma omp parallel
#pragma omp for reduction(+:sum)
</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_steps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">step</span><span class="p">;</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="mf">4.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>    
    <span class="kt">double</span> <span class="n">pi</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">*</span> <span class="n">step</span><span class="p">;</span>

    <span class="kt">double</span> <span class="n">end</span> <span class="o">=</span> <span class="n">omp_get_wtime</span><span class="p">(</span> <span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"pi: %.16g in %.16g secs</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h1 id="19-技能训练链表和openmp">19. 技能训练:链表和OpenMP</h1><p>到目前为止，介绍了</p><ul><li>To create a team of threads: <code class="language-plaintext highlighter-rouge">#pragma omp parallel</code><li>To share work between threads<ul><li><code class="language-plaintext highlighter-rouge">#pragma omp for</code><li><code class="language-plaintext highlighter-rouge">#pragma omp single</code></ul><li>To prevent conflicts(data races)<ul><li><code class="language-plaintext highlighter-rouge">#pragma omp critical</code><li><code class="language-plaintext highlighter-rouge">#pragma omp atomic</code><li><code class="language-plaintext highlighter-rouge">#pragma omp barrier</code><li><code class="language-plaintext highlighter-rouge">#pragma omp master</code></ul><li>Data environment clauses<ul><li><code class="language-plaintext highlighter-rouge">private(variable_list)</code><li><code class="language-plaintext highlighter-rouge">firstprivate(variable_list)</code><li><code class="language-plaintext highlighter-rouge">lastprivate(variable_list)</code><li><code class="language-plaintext highlighter-rouge">reduction(op:variable_list)</code></ul></ul><p>考虑如何将下面的链表遍历代码并行化，</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">process</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h1 id="20-讨论6-遍历链表的不同方法">20. 讨论6-遍历链表的不同方法</h1><p>Ugly solution</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">count</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">parr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#pragma omp parallel
</span><span class="p">{</span>
    <span class="cp">#pragma omp for schedule(static, 1)
</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">process</span><span class="p">(</span><span class="n">parr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h1 id="21-taskslinked-list-the-easy-way">21. Tasks(Linked List the Easy Way)</h1><p>Tasks are independent units of work.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="cp">#pragma omp task [clause[[,] clause]...]
</span><span class="p">{</span><span class="n">structured</span><span class="o">-</span><span class="n">block</span><span class="p">}</span>
</pre></table></code></div></div><p>Tasks are composed of:</p><ul><li>code to execute<li>data environment<li>internal control variables(ICV)</ul><p>The runtime system decides when tasks are executed.</p><p>例子：</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="cp">#pragma omp parallel
</span><span class="p">{</span>
    <span class="cp">#pragma omp task //每个线程创建一个任务foo()
</span>    <span class="n">foo</span><span class="p">();</span>
    <span class="cp">#pragma omp barrier
</span>    <span class="cp">#pragma omp single // 只有一个线程创建任务bar()
</span>    <span class="p">{</span>
        <span class="cp">#pragma omp task
</span>        <span class="n">bar</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1086 542'%3E%3C/svg%3E" data-proofer-ignore data-src="../../img/openMP/task-clause.png?raw=true" alt="Task clause" width="1086" height="542" /></p><h2 id="taskwait-directive"><code class="language-plaintext highlighter-rouge">taskwait</code> directive</h2><ul><li>It’s a stand-alone directive<div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>  <span class="cp">#pragma omp taskwait
</span></pre></table></code></div></div><li>wait in the completion of child tasks of the current task; just direct children, not all descendant tasks; includes an implicit task scheduling point(TSP)</ul><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1086 542'%3E%3C/svg%3E" data-proofer-ignore data-src="../../img/openMP/taskwait.png?raw=true" alt="taskwait" width="1086" height="542" /></p><h2 id="if-clause"><code class="language-plaintext highlighter-rouge">if</code> clause</h2><h3 id="the-if-clause-of-a-task-construct">The <code class="language-plaintext highlighter-rouge">if</code> clause of a task construct</h3><ul><li>allows to optimize task creation/execution<li>reduces parallelism but also reduces the pressure in the runtime’s task pool.<li>for “very” fine grain tasks you may need to do your own <code class="language-plaintext highlighter-rouge">if</code><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>  <span class="cp">#pragma omp task if (expression)
</span></pre></table></code></div></div><li>If the expression of the <code class="language-plaintext highlighter-rouge">if</code> clause evaluates to false<ul><li>the encountering task is suspended<li>the new task is executed immediately<li>the parent task resumes when the task finishes</ul><li>This is known as undeferred task <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1086 542'%3E%3C/svg%3E" data-proofer-ignore data-src="../../img/openMP/task-if-clause.png?raw=true" alt="task-if-clause" width="1086" height="542" /></ul><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1086 542'%3E%3C/svg%3E" data-proofer-ignore data-src="../../img/openMP/task-if-clause2.png?raw=true" alt="task-if-clause2" width="1086" height="542" /></p><h2 id="tasking-overheads">Tasking Overheads</h2><h3 id="typical-overheads-in-task-based-programs-are">Typical overheads in task-based programs are:</h3><ul><li>Task Creation: populate task data structure, add task to task queue<li>Task execution: retrieve a task from the queue(may including work stealing)</ul><h3 id="if-tasks-become-too-fine-grained-overhead-becomes-noticeable">If tasks become too fine-grained, overhead becomes noticeable</h3><ul><li>Execution spends a higher relative amount of time in the runtime<li>Task execution contributing to runtime becomes significantly smaller</ul><h3 id="a-rough-rule-of-thumb-to-avoidvisiable-tasking-overhead">A rough rule of thumb to avoid(visiable) tasking overhead</h3><ul><li>OpenMP tasks: 80-100k instructions executed per task<li>TBB tasks: 30-50k instructions executed per task<li>Other programming models may have another ideal granularity</ul><h2 id="tasks-vs-threads">Tasks vs Threads</h2><h3 id="threads-do-not-compose-well">Threads do not compose well</h3><ul><li>Example: multi-threaded plugin in a multi-threaded application<li>Composition usually leads to oversubscription and load imbalance</ul><h3 id="task-models-are-inherently-composable">Task models are inherently composable</h3><ul><li>A pool of threads executes all created tasks<li>Tasks from different modules can freely mix</ul><h3 id="task-models-make-complex-algorithms-easier-to-parallelize">Task models make complex algorithms easier to parallelize</h3><ul><li>Programmers can think in concurrent pieces of work<li>Mapping of concurrent execution to threads handled elsewhere<li>Task creation can bu irregular(e.g., recursion, graph traversal)</ul><h2 id="sometimes-you-are-better-off-with-threads">Sometimes you are better off with threads</h2><h3 id="some-scenarios-are-more-amenable-for-traditional-threads">Some scenarios are more amenable for traditional threads</h3><ul><li>Granularity too coarse for tasking<li>Isolation of autonomous agents</ul><h3 id="static-allocation-of-parallel-work-is-typically-easier-with-threads">Static allocation of parallel work is typically easier with threads</h3><ul><li>Controlling allocation of work to cache hierarchly</ul><h3 id="graphical-user-interfaceevent-thread--worker-threads">Graphical User Interface(event thread + worker threads)</h3><h3 id="requestresponse-processing-eg">Request/response processing, e.g.,</h3><ul><li>Web Server<li>Database servers</ul><h1 id="tasking-and-scoping">Tasking and Scoping</h1><h2 id="data-scoping-in-tasks">Data scoping in tasks</h2><h3 id="some-rules-from-parallel-regions-apply">Some rules from Parallel Regions apply</h3><ul><li>Automatic Storage(local) variables are private<li>Static and global variables are shared</ul><h3 id="tasking-variables-are-firstprivate-unless-shared-in-the-enclosing-context">Tasking: variables are firstprivate unless shared in the enclosing context</h3><ul><li>Only shared attribute is inherited<li>Exception: Orphaned Task variables are firstprivate by default</ul><h3 id="example">Example</h3><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="cp">#pragma omp parallel private(b)
</span>    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
        <span class="cp">#pragma omp task
</span>        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

            <span class="c1">// scope of a: shared,         value of a: 1</span>
            <span class="c1">// scope of b: firstprivate,   value of b: 0 or undefined</span>
            <span class="c1">// scope of c: shared,         value of c: 3</span>
            <span class="c1">// scope of d: firstprivate,   value of d: 4</span>
            <span class="c1">// scope of e: private,        value of e: 5</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1086 542'%3E%3C/svg%3E" data-proofer-ignore data-src="../../img/openMP/private-lifetime.png?raw=true" alt="private-lifetime" width="1086" height="542" /></p><h3 id="orphaned--task-variables">Orphaned Task Variables</h3><ul><li>Arguments passed by reference are <code class="language-plaintext highlighter-rouge">firstprivate</code> by default in orphaned task generating constructs, example: <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1086 542'%3E%3C/svg%3E" data-proofer-ignore data-src="../../img/openMP/orphaned-task-variables.png?raw=true" alt="private-lifetime" width="1086" height="542" /></ul><h1 id="22-讨论7-理解tasks">22. 讨论7-理解Tasks</h1><p>用task实现遍历链表</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="cp">#pragma omp parallel
</span><span class="p">{</span>
    <span class="cp">#pragma omp single
</span>    <span class="p">{</span>
        <span class="n">node</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="cp">#pragma omp task firstprivate(p);
</span>            <span class="n">process</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1086 542'%3E%3C/svg%3E" data-proofer-ignore data-src="../../img/openMP/execution-of-tasks.png" alt="reduction" width="1086" height="542" /></p><h1 id="23-可怕的东西内存模型atomicsflushpairwise同步">23. 可怕的东西:内存模型,Atomics,Flush(Pairwise同步)</h1><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1086 542'%3E%3C/svg%3E" data-proofer-ignore data-src="../../img/openMP/introduction-to-openmp-intel/openmp-memory-model.png" alt="reduction" width="1086" height="542" /></p><p><strong>sequential consistency</strong></p><p>在一个多核处理器中，操作(R/W/S)是sequential consistency的，如果：</p><ul><li>对于每个核，它们保持这代码中的顺序<li>其他每个处理器看到它们的总体顺序是相同的</ul><p>OpenMP defines consistency as a variant of weak consistency.</p><p>Can not reorder <code class="language-plaintext highlighter-rouge">S</code> ops with <code class="language-plaintext highlighter-rouge">R</code> or <code class="language-plaintext highlighter-rouge">W</code> ops on the same thread.</p><p>Weak consistency guarantees <code class="language-plaintext highlighter-rouge">S&gt;&gt;W</code>, <code class="language-plaintext highlighter-rouge">S&gt;&gt;R</code>, <code class="language-plaintext highlighter-rouge">R&gt;&gt;S</code>, <code class="language-plaintext highlighter-rouge">W&gt;&gt;S</code>, <code class="language-plaintext highlighter-rouge">S&gt;&gt;S</code></p><h3 id="flush">Flush</h3><p>Defines a sequence point at which a thread is guaranteed to see a consistent view of memory with respect to the <code class="language-plaintext highlighter-rouge">flush set</code>.</p><p>The flush set is:</p><ul><li>A list of variables when the <code class="language-plaintext highlighter-rouge">flush(list)</code> construct is used<li><code class="language-plaintext highlighter-rouge">All thread visiable variables</code> for a flush construct without an argument list</ul><p>The action of flush is to guarantee that:</p><ul><li>All R/W ops that overlap the flush set and occur prior to the flush complete before the flush executes.<li>All R/W ops that overlap the flush set and occur after the flush don’t execute until after the flush executes.<li>Flushes with overlapping flush sets can not be reordered.</ul><p>A flush operation is implied by OpenMP synchronizations, e.g.</p><ul><li>At entry/exit of parallel regions<li>At implicit and explicit barriers<li>At entry/exit of critical regions</ul><h1 id="24-讨论8-pairwise同步的陷阱">24. 讨论8-Pairwise同步的陷阱</h1><h3 id="pair-wise-synchronization-in-openmp">Pair Wise Synchronization in OpenMP</h3><p>OpenMP lacks synchronization constructs that work between pairs of threads. When this is needed, you have to build it yourself.</p><p>Pair Wise Synchronization:</p><ul><li>use a shared flag variable<li>reader spins waiting for the new flag value<li>use flushed to force updates to and form memory</ul><p>一个例子，生产者-消费者模型的例子。</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">double</span><span class="o">*</span> <span class="n">A</span><span class="p">,</span> <span class="n">sum</span><span class="p">,</span> <span class="n">runtime</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>

  <span class="n">fill_rand</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">A</span><span class="p">);</span>        <span class="c1">// producer: fill an array of data</span>

  <span class="n">sum</span> <span class="o">=</span> <span class="n">Sum_arrat</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">A</span><span class="p">);</span>  <span class="c1">// consumer: sum the array</span>
  
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>将上述例子用OpenMP并行化，如下所示，这个改法有个极低概率的bug，就是<code class="language-plaintext highlighter-rouge">flag = 1;</code>的操作不算原子的。</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">double</span><span class="o">*</span> <span class="n">A</span><span class="p">,</span> <span class="n">sum</span><span class="p">,</span> <span class="n">runtime</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>

  <span class="cp">#pragma omp prallel sections
</span>  <span class="p">{</span>
    <span class="cp">#pragma omp section
</span>    <span class="p">{</span>
      <span class="n">fill_rand</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">A</span><span class="p">);</span>        <span class="c1">// producer: fill an array of data</span>
      <span class="cp">#pragma omp flush
</span>      <span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="cp">#pragma omp flush (flag)
</span>    <span class="p">}</span>

    <span class="cp">#pragma omp section
</span>    <span class="p">{</span>
      <span class="cp">#pragma omp flush (flag)
</span>      <span class="k">while</span> <span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cp">#pragma omp flush (flag)
</span>      <span class="p">}</span>
      
      <span class="cp">#pragma omp flush
</span>      <span class="n">sum</span> <span class="o">=</span> <span class="n">Sum_arrat</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">A</span><span class="p">);</span>  <span class="c1">// consumer: sum the array</span>
    <span class="p">}</span>
  <span class="p">}</span>
  
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="atomic">atomic</h3><p>Atomic is expanded to cover the full range of common scenarios where you need to protect a memory operation so it occurs atomically.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="cp">#pragma omp atomic [read | write | update | capture]
</span></pre></table></code></div></div><ul><li><p>atomic can protect loads</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="cp">#pragma omp atomic read
</span>	<span class="n">v</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</pre></table></code></div></div><li><p>atomic can protect stores</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="cp">#pragma omp atomic write
</span>	<span class="n">x</span> <span class="o">=</span> <span class="n">expr</span><span class="p">;</span>
</pre></table></code></div></div></ul><p>用<code class="language-plaintext highlighter-rouge">atomic</code>解决非原子操作问题。代码如下所示。</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">double</span><span class="o">*</span> <span class="n">A</span><span class="p">,</span> <span class="n">sum</span><span class="p">,</span> <span class="n">runtime</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">flag_tmp</span><span class="p">;</span>
  <span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>

  <span class="cp">#pragma omp prallel sections
</span>  <span class="p">{</span>
    <span class="cp">#pragma omp section
</span>    <span class="p">{</span>
      <span class="n">fill_rand</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">A</span><span class="p">);</span>        <span class="c1">// producer: fill an array of data</span>
      <span class="cp">#pragma omp flush
</span>      <span class="cp">#pragma omp atomic write
</span>      <span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="cp">#pragma omp flush (flag)
</span>    <span class="p">}</span>

    <span class="cp">#pragma omp section
</span>    <span class="p">{</span>
      <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="cp">#pragma omp flush (flag)
</span>      <span class="cp">#pragma atomic write
</span>      <span class="n">flg_temp</span> <span class="o">=</span> <span class="n">flag</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">flag_tmp</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
      
      <span class="cp">#pragma omp flush
</span>      <span class="n">sum</span> <span class="o">=</span> <span class="n">Sum_arrat</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">A</span><span class="p">);</span>  <span class="c1">// consumer: sum the array</span>
    <span class="p">}</span>
  <span class="p">}</span>
  
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h1 id="25-线程私有数据和如何支持库pi-again">25. 线程私有数据和如何支持库(<code class="language-plaintext highlighter-rouge">Pi</code> again)</h1><p><code class="language-plaintext highlighter-rouge">threadprivate</code>: makes global data private to a thread.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#pragma omp threadprivate(counter) //每个线程都有一个counter变量，并且被初始化为0
</span>
<span class="kt">int</span> <span class="nf">increment_counter</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">counter</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">counter</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h1 id="26-讨论-9-随机数生成器">26. 讨论 9-随机数生成器</h1><p>蒙特卡洛法计算<code class="language-plaintext highlighter-rouge">pi</code>值</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;random&gt;</span><span class="cp">
</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">num_trails</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">calc_pi_montacalo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">Ncircle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">pi</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">r</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">random_device</span> <span class="n">rd</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">mt19937</span> <span class="n">rng</span><span class="p">(</span><span class="n">rd</span><span class="p">());</span>
    <span class="n">std</span><span class="o">::</span><span class="n">uniform_real_distribution</span><span class="o">&lt;&gt;</span> <span class="n">dist</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
    
    <span class="cp">#pragma omp parallel for private(x, y) reduction(+:Ncircle)
</span>    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_trails</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">rng</span><span class="p">);</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">rng</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Ncircle</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">pi</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="p">((</span><span class="kt">double</span><span class="p">)</span><span class="n">Ncircle</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">num_trails</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">%d trails, pi is %f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">num_trails</span><span class="p">,</span> <span class="n">pi</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="线性同余法">线性同余法</h3><p>Linear Congruential Generator(LCG): easy to write, cheap to compute, portable, OK quality.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">random_next</span> <span class="o">=</span> <span class="p">(</span><span class="n">MULTIPLIER</span><span class="o">*</span> <span class="n">random_last</span> <span class="o">+</span> <span class="n">ADDEND</span><span class="p">)</span> <span class="o">%</span> <span class="n">PMOD</span><span class="p">;</span>
<span class="n">random_last</span> <span class="o">=</span> <span class="n">random_next</span><span class="p">;</span>
</pre></table></code></div></div><p>If you pick the multiplier and addend correctly, LCG has a period of PMOD.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="cm">/* simple single thread version */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">MULTIPLIER</span> <span class="o">=</span> <span class="mi">1366</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">ADDEND</span> <span class="o">=</span> <span class="mi">150889</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">PMOD</span> <span class="o">=</span> <span class="mi">714025</span><span class="p">;</span>
<span class="kt">long</span> <span class="n">random_last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">double</span> <span class="nf">random</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">long</span> <span class="n">random_next</span><span class="p">;</span>
    <span class="n">random_next</span> <span class="o">=</span> <span class="p">(</span><span class="n">MULTIPLIER</span><span class="o">*</span> <span class="n">random_last</span> <span class="o">+</span> <span class="n">ADDEND</span><span class="p">)</span> <span class="o">%</span> <span class="n">PMOD</span><span class="p">;</span>
    <span class="n">random_last</span> <span class="o">=</span> <span class="n">random_next</span><span class="p">;</span>

    <span class="k">return</span> <span class="p">((</span><span class="kt">double</span><span class="p">)</span><span class="n">random_next</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">PMOD</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h1 id="27-概括">27. 概括</h1><p>新手并行程序员与专家并行程序员之间的区别是专家have a collection of these fundamental <strong>design patterns</strong> in their minds.</p><h3 id="spmd">SPMD</h3><p>Single Program Multiple Data: Run the same program on P processing elements where P can be arbitrarily large.</p><p>Use the rank - an ID ranging from 0 to (P-1) - to select between a set of tasks and to manage any shared data structures.</p><p>例子：</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"omp.h"</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">step</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">sum</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="n">step</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">num_steps</span><span class="p">;</span>
    
    <span class="cp">#pragma omp parallel firstprivate(sum) private(x, i)
</span>    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">omp_get_threads_num</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">numprocs</span> <span class="o">=</span> <span class="n">omp_get_num_threads</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">step1</span> <span class="o">=</span> <span class="n">id</span> <span class="o">*</span> <span class="n">num_steps</span> <span class="o">/</span> <span class="n">numprocs</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">stepN</span> <span class="o">=</span> <span class="p">(</span><span class="n">id</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_steps</span> <span class="o">/</span> <span class="n">numprocs</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="n">numprocs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">stepN</span> <span class="o">=</span> <span class="n">num_steps</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">ri</span> <span class="o">=</span> <span class="n">step1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">stepN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">step</span><span class="p">;</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="mf">4.0</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="cp">#pragma omp critical
</span>        	<span class="n">pi</span> <span class="o">+=</span> <span class="n">sum</span><span class="o">*</span><span class="n">step</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="loop-parallelism">Loop Parallelism</h3><p>Collections of tasks are defined as iterations of one or more loops.</p><p>Loop iterations are divided between a collection of processing elements to compute tasks in parallel.</p><p>例子：</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">calc_pi_reduction</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">long</span> <span class="n">num_steps</span> <span class="o">=</span> <span class="mh">0x20000000</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">step</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="n">step</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">num_steps</span><span class="p">;</span>

    <span class="kt">double</span> <span class="n">start</span> <span class="o">=</span> <span class="n">omp_get_wtime</span><span class="p">(</span> <span class="p">);</span>    
<span class="cp">#pragma omp parallel
#pragma omp for reduction(+:sum)
</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_steps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">step</span><span class="p">;</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="mf">4.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>    
    <span class="kt">double</span> <span class="n">pi</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">*</span> <span class="n">step</span><span class="p">;</span>

    <span class="kt">double</span> <span class="n">end</span> <span class="o">=</span> <span class="n">omp_get_wtime</span><span class="p">(</span> <span class="p">);</span>
    
    <span class="n">printf</span><span class="p">(</span><span class="s">"pi: %.16g in %.16g secs</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="分治pattern">分治Pattern</h3><ul><li><p>当问题存在<strong>分解成子问题的方法</strong>和<strong>将子问题的解重新组合为全局解的方法</strong>时使用。</p><li><p>定义一个分解操作。</p><li><p>持续分解直到子问题小到可以直接求解。</p><li><p>将子问题的解组合起来解决原始的全局问题。</p></ul><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1086 542'%3E%3C/svg%3E" data-proofer-ignore data-src="../../img/openMP/divide-and-conquer.png" alt="image" width="1086" height="542" /></p><p>例子：</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"omp.h"</span><span class="cp">
</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">num_steps</span> <span class="o">=</span> <span class="mi">100000000</span><span class="p">;</span>
<span class="cp">#define MIN_BLK 10000000
</span><span class="kt">double</span> <span class="nf">pi_comp</span><span class="p">(</span><span class="kt">int</span> <span class="n">Nstart</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Nfinish</span><span class="p">,</span> <span class="kt">double</span> <span class="n">step</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">iblk</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">sum</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">sum1</span><span class="p">,</span> <span class="n">sum2</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">Nfinish</span> <span class="o">-</span> <span class="n">Nstart</span> <span class="o">&lt;</span> <span class="n">MIN_BLK</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">Nstart</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Nfinish</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">step</span><span class="p">;</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="mf">4.0</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">);</span>            
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">iblk</span> <span class="o">=</span> <span class="n">Nfinish</span> <span class="o">-</span> <span class="n">Nstart</span><span class="p">;</span>
        <span class="cp">#pragma omp task shared(sum1)
</span>          <span class="n">sum1</span> <span class="o">=</span> <span class="n">pi_comp</span><span class="p">(</span><span class="n">Nstart</span><span class="p">,</span> <span class="n">Nfinish</span> <span class="o">-</span> <span class="n">iblk</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">step</span><span class="p">);</span>
        <span class="cp">#pragma omp task shared(sum2)
</span>          <span class="n">sum2</span> <span class="o">=</span> <span class="n">pi_comp</span><span class="p">(</span><span class="n">Nfinish</span> <span class="o">-</span> <span class="n">iblk</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">Nfinish</span><span class="p">,</span> <span class="n">step</span><span class="p">);</span>
        <span class="cp">#pragma omp taskwait
</span>        <span class="n">sum</span> <span class="o">=</span> <span class="n">sum1</span> <span class="o">+</span> <span class="n">sum2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">step</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">sum</span><span class="p">;</span>
    <span class="n">step</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">num_steps</span><span class="p">;</span>
    <span class="cp">#pragma omp parallel
</span>    <span class="p">{</span>
        <span class="cp">#pragma omp single
</span>		<span class="n">sum</span> <span class="o">=</span> <span class="n">pi_comp</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_steps</span><span class="p">,</span> <span class="n">step</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">pi</span> <span class="o">=</span> <span class="n">step</span> <span class="o">*</span> <span class="n">sum</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>       
<span class="p">}</span>
</pre></table></code></div></div><h1 id="推荐的参考书">推荐的参考书</h1><ul><li><p>“<em>Using OpenMP-portable shared memory parallel programing</em>”</p><li><p>“<em>Patterns for Parallel Programing</em>”</p><li><p>“<em>Introduction to Concurrency in Programming Languages</em>”</p><li><p>“<em>The Art of Concurrency</em>”</p></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/openmp/'>openMP</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/openmp/" class="post-tag no-text-decoration" >openMP</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Introduction to openMP - zuo&url=https://dazuozcy.github.io/posts/introdution-to-openmp-intel/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Introduction to openMP - zuo&u=https://dazuozcy.github.io/posts/introdution-to-openmp-intel/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Introduction to openMP - zuo&url=https://dazuozcy.github.io/posts/introdution-to-openmp-intel/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/simd/">SIMD</a><li><a href="/posts/new-from-cpp11/">C++11开始的新特性</a><li><a href="/posts/keywords/">关键字</a><li><a href="/posts/empty-class/">class的内存模型</a><li><a href="/posts/diff-between-c-cpp/">C++ vs C</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/gpu/">GPU</a> <a class="post-tag" href="/tags/cuda/">CUDA</a> <a class="post-tag" href="/tags/openmp/">openMP</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/parallel-computing/">Parallel Computing</a> <a class="post-tag" href="/tags/python/">Python</a> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/forecasting-at-scale/">Forecasting at Scale</a> <a class="post-tag" href="/tags/onednn/">oneDNN</a> <a class="post-tag" href="/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">智能指针</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/openmp-in-onednn/"><div class="card-body"> <span class="timeago small" > Jul 3, 2020 <i class="unloaded">2020-07-03T20:19:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>OpenMP in oneDNN</h3><div class="text-muted small"><p> 本文介绍下OpenMP在oneDNN库中的使用。 parallel() oneDNN中CPU上多线程并行的基础是parallel()函数，将与OpenMP无关的内容删除以后，精简如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // src/common/dnnl_thread_p...</p></div></div></a></div><div class="card"> <a href="/posts/openmp-increasing-mem-use/"><div class="card-body"> <span class="timeago small" > Jul 3, 2020 <i class="unloaded">2020-07-03T20:19:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>OpenMP库持续增加的内存占用</h3><div class="text-muted small"><p> 背景 在长稳执行某网络时，出现了内存占用持续上升的问题。经过初步分析隔离，发现是某些算子引入的，因为把那几个算子打桩掉后，内存占用就稳定了。那几个算子有个共性，底层是调用的oneDNN库实现的。oneDNN库的算子有内存泄漏问题？ 目标 分析oneDNN库的那几个算子为什么会内存泄漏。 定位过程 选择其中一个算子，梳理出调用流程，发现几处显式申请释放内存的操作，但都是严格匹配的，不...</p></div></div></a></div><div class="card"> <a href="/posts/openmp/"><div class="card-body"> <span class="timeago small" > Jul 3, 2020 <i class="unloaded">2020-07-03T20:19:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>openMP</h3><div class="text-muted small"><p> Intro OpenMP是共享内存体系结构上的一个基于多线程的并行编程模型，适用于SMP共享内存多处理系统和多核处理器体系结构。支持C/C++/Fortran. OpenMP由三部分组成 编译器指令(compiler directives) 运行时库程序(runtime routines) 环境变量(environment variables) OpenMP’s mac...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/object-oriented-character/" class="btn btn-outline-primary" prompt="Older"><p>面向对象的特性</p></a> <a href="/posts/openmp-in-onednn/" class="btn btn-outline-primary" prompt="Newer"><p>OpenMP in oneDNN</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/dazuozcy">zuo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/gpu/">GPU</a> <a class="post-tag" href="/tags/cuda/">CUDA</a> <a class="post-tag" href="/tags/openmp/">openMP</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/parallel-computing/">Parallel Computing</a> <a class="post-tag" href="/tags/python/">Python</a> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/forecasting-at-scale/">Forecasting at Scale</a> <a class="post-tag" href="/tags/onednn/">oneDNN</a> <a class="post-tag" href="/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">智能指针</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { let initTheme = "default"; if ($("html[mode=dark]").length > 0 || ($("html[mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://dazuozcy.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script async src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script>
